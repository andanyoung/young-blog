---
title: Spark 核心编程
date: 2023-12-04 09:14:58
permalink: /bigdata/spark/core_RDD/
categories:
  - 大数据
  - spark
tags:
  -
author:
  name: andanyang
  link: https://github.com/andanyoung
---

Spark 计算框架为了能够进行高并发和高吞吐的数据处理，封装了三大数据结构，用于处理不同的应用场景。三大

数据结构分别是： 

➢ RDD : 弹性分布式数据集 

➢ 累加器：分布式共享只写变量 

➢ 广播变量：分布式共享只读变量 

接下来我们一起看看这三大数据结构是如何在数据处理中使用的。

# 1 RDD

## 1.1 什么是 RDD

RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是 Spark 中最基本的**数据处理模型**。代码中是一个抽象类，它代表一个弹性的、不可变、可分区、里面的元素可并行计算的集合。

➢ 弹性 

- 存储的弹性：内存与磁盘的自动切换； 
-  容错的弹性：数据丢失可以自动恢复； 
-  计算的弹性：计算出错重试机制； 
-  分片的弹性：可根据需要重新分片。 

➢ 分布式：数据存储在大数据集群不同节点上 

➢ 数据集：RDD 封装了计算逻辑，并不保存数据 

➢ 数据抽象：RDD 是一个抽象类，需要子类具体实现 

➢ 不可变：RDD 封装了计算逻辑，是不可以改变的，想要改变，只能产生新的 RDD，在新的 RDD 里面封装计算逻辑 

➢ 可分区、并行计算

## 1.2 核心属性

> Internally, each RDD is characterized by five main properties:
> - A list of partitions
> - A function for computing each split
> - A list of dependencies on other RDDs
> - Optionally, a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned)
> Optionally, a list of preferred locations to compute each split on (e.g. block locations for an HDFS file)
> All of the scheduling and execution in Spark is done based on these methods, allowing each RDD to implement its own way of computing itself. Indeed, users can implement custom RDDs (e.g. for reading data from a new storage system) by overriding these functions. Please refer to the Spark paper  for more details on RDD internals.

➢ 分区列表 (A list of partitions)

RDD 数据结构中存在分区列表，用于执行任务时并行计算，是实现分布式计算的重要属性。

![image-20231204233941171](../../.vuepress/public/spark/image-20231204233941171.png)

➢ 分区计算函数 

Spark 在计算时，是使用分区函数对每一个分区进行计算

![image-20231204234008340](../../.vuepress/public/spark/image-20231204234008340.png)

➢ RDD 之间的依赖关系 

RDD 是计算模型的封装，当需求中需要将多个计算模型进行组合时，就需要将多个 RDD 建立依赖关系

![image-20231204234048770](../../.vuepress/public/spark/image-20231204234048770.png)

➢ 首选位置（可选）

计算数据时，可以根据计算节点的状态选择不同的节点位置进行计算

![image-20231204234147876](../../.vuepress/public/spark/image-20231204234147876.png)

## 1.3 执行原理

从计算的角度来讲，数据处理过程中需要计算资源（内存 & CPU）和计算模型（逻辑）。 执行时，需要将计算资源和计算模型进行协调和整合。

Spark 框架在执行时，先申请资源，然后将应用程序的数据处理逻辑分解成一个一个的计算任务。然后将任务发到已经分配资源的计算节点上, 按照指定的计算模型进行数据计算。最后得到计算结果。

RDD 是 Spark 框架中用于数据处理的核心模型，接下来我们看看，在 Yarn 环境中，RDD 的工作原理: 

1. 启动 Yarn 集群环境

    ![启动 Yarn 集群环境](../../.vuepress/public/spark/image-20231204234324313.png)

2. Spark 通过申请资源创建调度节点和计算节点

    ![image-20231204234401911](../../.vuepress/public/spark/image-20231204234401911.png)

3. Spark 框架根据需求将计算逻辑根据分区划分成不同的任务

    ![image-20231204234438158](../../.vuepress/public/spark/image-20231204234438158.png)

    4. 度节点将任务根据计算节点状态发送到对应的计算节点进行计算

        ![image-20231204234500587](../../.vuepress/public/spark/image-20231204234500587.png)

        从以上流程可以看出 RDD 在整个流程中主要用于将逻辑进行封装，并生成 Task 发送给 Executor 节点执行计算，接下来我们就一起看看 Spark 框架中 RDD 是具体是如何进行数据处理的。

## 1.4 基础编程

## 1.4.1 RDD 创建

在 Spark 中创建 RDD 的创建方式可以分为四种：

#### 1 从集合（内存）中创建 RDD

从集合中创建 RDD，Spark 主要提供了两个方法：parallelize 和 makeRDD

```
            val sparkConf = new SparkConf().setMaster("local[*]").setAppName("spark")
            val sparkContext = new SparkContext(sparkConf)
            val rdd1 = sparkContext.parallelize(
             List(1,2,3,4)
            )
            val rdd2 = sparkContext.makeRDD(
             List(1,2,3,4)
            )
            rdd1.collect().foreach(println)
            rdd2.collect().foreach(println)
            sparkContext.stop()
```
 从底层代码实现来讲，makeRDD 方法其实就是 parallelize 方法
```
            def makeRDD[T: ClassTag](
             seq: Seq[T],
             numSlices: Int = defaultParallelism): RDD[T] = withScope {
             parallelize(seq, numSlices)
            }
```

####  2.从外部存储（文件）创建 RDD

由外部存储系统的数据集创建 RDD 包括：本地的文件系统，所有 Hadoop 支持的数据集， 比如 HDFS、HBase 等。

```
val sparkConf = new SparkConf().setMaster("local[*]").setAppName("spark")
val sparkContext = new SparkContext(sparkConf)
val fileRDD: RDD[String] = sparkContext.textFile("input")
fileRDD.collect().foreach(println)
sparkContext.stop()

```

#### 3. 从其他 RDD 创建

主要是通过一个 RDD 运算完后，再产生新的 RDD。详情请参考后续章节

#### 4. 直接创建 RDD（new）

使用 new 的方式直接构造 RDD，一般由 Spark 框架自身使用。

### 1.4.2 RDD 并行度与分区

默认情况下，Spark 可以将一个作业切分多个任务后，发送给 Executor 节点并行计算，而能够并行计算的任务数量我们称之为并行度。这个数量可以在构建 RDD 时指定。记住，这里的**并行执行的任务数量**，并不是指的切分任务的数量，不要混淆了。

```
val sparkConf =new SparkConf().setMaster("local[*]").setAppName("spark")
val sparkContext = new SparkContext(sparkConf)
val dataRDD: RDD[Int] =
 sparkContext.makeRDD(
 List(1,2,3,4), 4)
val fileRDD: RDD[String] =
 sparkContext.textFile(
 "input",
 2)
fileRDD.collect().foreach(println)
sparkContext.stop()
```

读取内存数据时，数据可以按照并行度的设定进行数据的分区操作，数据分区规则的 Spark 核心源码如下：

```
def positions(length: Long, numSlices: Int): Iterator[(Int, Int)] = {
 (0 until numSlices).iterator.map { i =>
 val start = ((i * length) / numSlices).toInt
 val end = (((i + 1) * length) / numSlices).toInt
 (start, end)
 }
}
```

读取文件数据时，数据是按照 Hadoop 文件读取的规则进行切片分区，而切片规则和数 据读取的规则有些差异，具体 Spark 核心源码如下

```
public InputSplit[] getSplits(JobConf job, int numSplits)
 throws IOException {
 long totalSize = 0; // compute total size
 for (FileStatus file: files) { // check we have valid files
 if (file.isDirectory()) {
 throw new IOException("Not a file: "+ file.getPath());
 }
 totalSize += file.getLen();
 }
 long goalSize = totalSize / (numSplits == 0 ? 1 : numSplits);
 long minSize = Math.max(job.getLong(org.apache.hadoop.mapreduce.lib.input.
 FileInputFormat.SPLIT_MINSIZE, 1), minSplitSize);
 
 ...
 
 for (FileStatus file: files) {
 
 ...
 
 if (isSplitable(fs, path)) {
 long blockSize = file.getBlockSize();
 long splitSize = computeSplitSize(goalSize, minSize, blockSize);
 ...
 }
 protected long computeSplitSize(long goalSize, long minSize,
 long blockSize) {
 return Math.max(minSize, Math.min(goalSize, blockSize));
 }
```

### 1.4.3 RDD 转换算子

RDD 根据数据处理方式的不同将算子整体上分为 Value 类型、双 Value 类型和 Key-Value 类型

#### Value 类型

##### 1) map

➢ 函数签名 

`def map[U: ClassTag](f: T => U): RDD[U]`

➢ 函数说明

将处理的数据逐条进行映射转换，这里的转换可以是类型的转换，也可以是值的转换。

```
val dataRDD: RDD[Int] = sparkContext.makeRDD(List(1,2,3,4))
val dataRDD1: RDD[Int] = dataRDD.map(
 num => {
 	num * 2
 }
)
val dataRDD2: RDD[String] = dataRDD1.map(
 num => {
 	"" + num
 }
)
```

##### 2) mapPartitions

➢ 函数签名 

```
def mapPartitions[U: ClassTag](
 f: Iterator[T] => Iterator[U],
 preservesPartitioning: Boolean = false): RDD[U]
```

➢ 函数说明 

将待处理的数据**以分区为单位**发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据。

```
val dataRDD1: RDD[Int] = dataRDD.mapPartitions(
 datas => {
 	datas.filter(_==2)
 }
)
```

###### 思考一个问题：map 和 mapPartitions 的区别？

➢ 数据处理角度 

Map 算子是分区内一个数据一个数据的执行，类似于串行操作。而 mapPartitions 算子是以分区为单位进行批处理操作。 

➢ 功能的角度 

Map 算子主要目的将数据源中的数据进行转换和改变。但是不会减少或增多数据。 MapPartitions 算子需要传递一个迭代器，返回一个迭代器，没有要求的元素的个数保持不变， 所以可以增加或减少数据 

➢ 性能的角度 

Map 算子因为类似于串行操作，所以性能比较低，而是 mapPartitions 算子类似于批处理，所以性能较高。但是 mapPartitions 算子会长时间占用内存，那么这样会导致内存可能不够用，出现内存溢出的错误。所以在内存有限的情况下，不推荐使用。使用 map 操作。

##### 3) mapPartitionsWithIndex

➢ 函数签名

```
def mapPartitionsWithIndex[U: ClassTag](
 f: (Int, Iterator[T]) => Iterator[U],
 preservesPartitioning: Boolean = false): RDD[U]
```

➢ 函数说明 

将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据，在处理时同时可以获取当前分区索引。

##### 4) flatMap

➢ 函数签名

```
def flatMap[U: ClassTag](f: T => TraversableOnce[U]): RDD[U]
```

➢ 函数说明 

将处理的数据进行扁平化后再进行映射处理，所以算子也称之为扁平映射

```
val dataRDD = sparkContext.makeRDD(List(
 List(1,2),List(3,4)
),1)
val dataRDD1 = dataRDD.flatMap(
 list => list
)
```

##### 5) glom

➢ 函数签名

```
def glom(): RDD[Array[T]]
```

➢ 函数说明

将同一个分区的数据直接转换为相同类型的内存数组进行处理，分区不变

```
val dataRDD = sparkContext.makeRDD(List(
 1,2,3,4
),1)
val dataRDD1:RDD[Array[Int]] = dataRDD.glom()
```

##### 6) groupBy

➢ 函数签名

```
def groupBy[K](f: T => K)(implicit kt: ClassTag[K]): RDD[(K, Iterable[T])]
```

➢ 函数说明 

将数据根据指定的规则进行分组, 分区默认不变，但是数据会被打乱重新组合，我们将这样的操作称之为 **shuffle**。极限情况下，数据可能被分在同一个分区中一个组的数据在一个分区中，但是**并不是说一个分区中只有一个组**

```
val dataRDD = sparkContext.makeRDD(List(1,2,3,4),1)
val dataRDD1 = dataRDD.groupBy(
 _%2
)
```

##### 7) filter

➢ 函数签名

```
def filter(f: T => Boolean): RDD[T]
```

➢ 函数说明 

将数据根据指定的规则进行筛选过滤，符合规则的数据保留，不符合规则的数据丢弃。 当数据进行筛选过滤后，分区不变，但是分区内的数据可能不均衡，生产环境下，可能会出现**数据倾斜**。

```
val dataRDD = sparkContext.makeRDD(List(
 1,2,3,4
),1)
val dataRDD1 = dataRDD.filter(_%2 == 0)
```

##### 8) sample

➢ 函数签名

```
def sample(
 withReplacement: Boolean,
 fraction: Double,
 seed: Long = Utils.random.nextLong): RDD[T]
```

➢ 函数说明

根据指定的规则从数据集中**抽取**数据

```
val dataRDD = sparkContext.makeRDD(List(
 1,2,3,4
),1)
// 抽取数据不放回（伯努利算法）
// 伯努利算法：又叫 0、1 分布。例如扔硬币，要么正面，要么反面。
// 具体实现：根据种子和随机算法算出一个数和第二个参数设置几率比较，小于第二个参数要，大于不要
// 第一个参数：抽取的数据是否放回，false：不放回
// 第二个参数：抽取的几率，范围在[0,1]之间,0：全不取；1：全取；
// 第三个参数：随机数种子
val dataRDD1 = dataRDD.sample(false, 0.5)
// 抽取数据放回（泊松算法）
// 第一个参数：抽取的数据是否放回，true：放回；false：不放回
// 第二个参数：重复数据的几率，范围大于等于 0.表示每一个元素被期望抽取到的次数
// 第三个参数：随机数种子
val dataRDD2 = dataRDD.sample(true, 2)
```

##### 9) distinct

➢ 函数签名

```
def distinct()(implicit ord: Ordering[T] = null): RDD[T]
def distinct(numPartitions: Int)(implicit ord: Ordering[T] = null): RDD[T]
```

➢ 函数说明 

将数据集中重复的数据去重

```
val dataRDD = sparkContext.makeRDD(List(
 1,2,3,4,1,2
),1)
val dataRDD1 = dataRDD.distinct()
val dataRDD2 = dataRDD.distinct(2)
```

##### 10) coalesce

➢ 函数签名

```
def coalesce(numPartitions: Int, shuffle: Boolean = false,
 partitionCoalescer: Option[PartitionCoalescer] = Option.empty)
 (implicit ord: Ordering[T] = null)
 : RDD[T]
```

➢ 函数说明

根据数据量**缩减分区**，用于大数据集过滤后，提高小数据集的执行效率。当 spark 程序中，存在过多的小任务的时候，可以通过 coalesce 方法，收缩合并分区，减少分区的个数，减小任务调度成本

```
val dataRDD = sparkContext.makeRDD(List(
 1,2,3,4,1,2
),6)
val dataRDD1 = dataRDD.coalesce(2)
```

##### 11) repartition

➢ 函数签名

```
def repartition(numPartitions: Int)(implicit ord: Ordering[T] = null): RDD[T]
```

➢ 函数说明

该操作内部其实执行的是 coalesce 操作，参数 shuffle 的默认值为 true。无论是将分区数多的 RDD 转换为分区数少的 RDD，还是将分区数少的 RDD 转换为分区数多的 RDD，repartition 操作都可以完成，因为无论如何都会经 shuffle 过程。

```
val dataRDD = sparkContext.makeRDD(List(
 1,2,3,4,1,2
),2)
val dataRDD1 = dataRDD.repartition(4)
```

> coalesce 和 repartition 区别？
>
> TODO

##### 12) sortBy

➢ 函数签名

```
def sortBy[K](
 f: (T) => K,
 ascending: Boolean = true,
 numPartitions: Int = this.partitions.length)
 (implicit ord: Ordering[K], ctag: ClassTag[K]): RDD[T
```

➢ 函数说明 

该操作用于排序数据。在排序之前，可以将数据通过 f 函数进行处理，之后按照 f 函数处理 的结果进行排序，默认为升序排列。排序后新产生的 RDD 的分区数与原 RDD 的分区数一致。中间存在 shuffle 的过程

```
val dataRDD = sparkContext.makeRDD(List(
 1,2,3,4,1,2
),2)
val dataRDD1 = dataRDD.sortBy(num=>num, false, 4)
```

