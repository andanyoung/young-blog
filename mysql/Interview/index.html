<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试官：MySQL连环炮，你扛得住嘛？ | Young&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="Young丶java后端技术博客,专注后端学习与总结。擅长spring boot,JAVA基础总结,等方面的知识,关注spring,架构,elasticsearch,mysql领域.">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.d9c8cf8c.css" as="style"><link rel="preload" href="/assets/js/app.47dc12bc.js" as="script"><link rel="preload" href="/assets/js/2.3e7974e5.js" as="script"><link rel="preload" href="/assets/js/32.d4d0d436.js" as="script"><link rel="prefetch" href="/assets/js/10.8664554a.js"><link rel="prefetch" href="/assets/js/100.1f62bc50.js"><link rel="prefetch" href="/assets/js/101.26c28ec4.js"><link rel="prefetch" href="/assets/js/102.c7733e82.js"><link rel="prefetch" href="/assets/js/103.c7edb874.js"><link rel="prefetch" href="/assets/js/104.a61645fb.js"><link rel="prefetch" href="/assets/js/105.92ca2bed.js"><link rel="prefetch" href="/assets/js/106.79d3a764.js"><link rel="prefetch" href="/assets/js/107.f557f0a2.js"><link rel="prefetch" href="/assets/js/108.96ad30ad.js"><link rel="prefetch" href="/assets/js/109.bb84b134.js"><link rel="prefetch" href="/assets/js/11.9969510c.js"><link rel="prefetch" href="/assets/js/110.39f1a3d0.js"><link rel="prefetch" href="/assets/js/111.5e105153.js"><link rel="prefetch" href="/assets/js/112.9f3e1af9.js"><link rel="prefetch" href="/assets/js/113.c1a3f9e4.js"><link rel="prefetch" href="/assets/js/114.0e73a948.js"><link rel="prefetch" href="/assets/js/115.ee86b7f5.js"><link rel="prefetch" href="/assets/js/116.604b1e1a.js"><link rel="prefetch" href="/assets/js/117.2c7a1ffb.js"><link rel="prefetch" href="/assets/js/118.1e33dc7c.js"><link rel="prefetch" href="/assets/js/119.bcfb058b.js"><link rel="prefetch" href="/assets/js/12.294a896d.js"><link rel="prefetch" href="/assets/js/120.fb07849d.js"><link rel="prefetch" href="/assets/js/121.aeb25466.js"><link rel="prefetch" href="/assets/js/122.5d63d009.js"><link rel="prefetch" href="/assets/js/123.27e9d9e9.js"><link rel="prefetch" href="/assets/js/124.cc72e6ca.js"><link rel="prefetch" href="/assets/js/125.fdb3bf97.js"><link rel="prefetch" href="/assets/js/126.01d33592.js"><link rel="prefetch" href="/assets/js/127.e59a3e95.js"><link rel="prefetch" href="/assets/js/128.b01a48ac.js"><link rel="prefetch" href="/assets/js/129.388cf6bf.js"><link rel="prefetch" href="/assets/js/13.64a29ce4.js"><link rel="prefetch" href="/assets/js/130.5fdcd7c7.js"><link rel="prefetch" href="/assets/js/131.051f43da.js"><link rel="prefetch" href="/assets/js/132.07fe59f4.js"><link rel="prefetch" href="/assets/js/133.9b04c95f.js"><link rel="prefetch" href="/assets/js/134.20e639a0.js"><link rel="prefetch" href="/assets/js/135.9a55b416.js"><link rel="prefetch" href="/assets/js/136.f096b289.js"><link rel="prefetch" href="/assets/js/137.c60774da.js"><link rel="prefetch" href="/assets/js/138.53c48fa8.js"><link rel="prefetch" href="/assets/js/139.3f8ace6e.js"><link rel="prefetch" href="/assets/js/14.75af9d1c.js"><link rel="prefetch" href="/assets/js/15.ed270df4.js"><link rel="prefetch" href="/assets/js/16.18904bef.js"><link rel="prefetch" href="/assets/js/17.a157a11b.js"><link rel="prefetch" href="/assets/js/18.23107193.js"><link rel="prefetch" href="/assets/js/19.421a7744.js"><link rel="prefetch" href="/assets/js/20.4d4ada6e.js"><link rel="prefetch" href="/assets/js/21.8e78d379.js"><link rel="prefetch" href="/assets/js/22.56eda9c6.js"><link rel="prefetch" href="/assets/js/23.875c04f6.js"><link rel="prefetch" href="/assets/js/24.7bd233f8.js"><link rel="prefetch" href="/assets/js/25.41518a47.js"><link rel="prefetch" href="/assets/js/26.f9160343.js"><link rel="prefetch" href="/assets/js/27.17903251.js"><link rel="prefetch" href="/assets/js/28.7b7fad17.js"><link rel="prefetch" href="/assets/js/29.1138b1b7.js"><link rel="prefetch" href="/assets/js/3.c4a9559d.js"><link rel="prefetch" href="/assets/js/30.1f54bb17.js"><link rel="prefetch" href="/assets/js/31.3cc69d0c.js"><link rel="prefetch" href="/assets/js/33.a6856d11.js"><link rel="prefetch" href="/assets/js/34.7068d491.js"><link rel="prefetch" href="/assets/js/35.37ee253c.js"><link rel="prefetch" href="/assets/js/36.825e0938.js"><link rel="prefetch" href="/assets/js/37.8ce71eac.js"><link rel="prefetch" href="/assets/js/38.8058ea6f.js"><link rel="prefetch" href="/assets/js/39.11d824e6.js"><link rel="prefetch" href="/assets/js/4.607c3e6b.js"><link rel="prefetch" href="/assets/js/40.ce1e9a3e.js"><link rel="prefetch" href="/assets/js/41.82ec8a9d.js"><link rel="prefetch" href="/assets/js/42.918731b9.js"><link rel="prefetch" href="/assets/js/43.7e47495a.js"><link rel="prefetch" href="/assets/js/44.b0a39aac.js"><link rel="prefetch" href="/assets/js/45.6d6f0672.js"><link rel="prefetch" href="/assets/js/46.051d4395.js"><link rel="prefetch" href="/assets/js/47.1bc3a3c4.js"><link rel="prefetch" href="/assets/js/48.c0db1068.js"><link rel="prefetch" href="/assets/js/49.940376f2.js"><link rel="prefetch" href="/assets/js/5.a0440d5c.js"><link rel="prefetch" href="/assets/js/50.34052706.js"><link rel="prefetch" href="/assets/js/51.65f43cba.js"><link rel="prefetch" href="/assets/js/52.823d0376.js"><link rel="prefetch" href="/assets/js/53.34f0ce75.js"><link rel="prefetch" href="/assets/js/54.de4f6d9e.js"><link rel="prefetch" href="/assets/js/55.b79bda90.js"><link rel="prefetch" href="/assets/js/56.57ab3cdf.js"><link rel="prefetch" href="/assets/js/57.dfd8a49a.js"><link rel="prefetch" href="/assets/js/58.3adb7017.js"><link rel="prefetch" href="/assets/js/59.ff439b24.js"><link rel="prefetch" href="/assets/js/6.71fddea1.js"><link rel="prefetch" href="/assets/js/60.1fee0f85.js"><link rel="prefetch" href="/assets/js/61.8a541ecf.js"><link rel="prefetch" href="/assets/js/62.142f2003.js"><link rel="prefetch" href="/assets/js/63.a01e0981.js"><link rel="prefetch" href="/assets/js/64.a49629ea.js"><link rel="prefetch" href="/assets/js/65.8bf6d356.js"><link rel="prefetch" href="/assets/js/66.4461b364.js"><link rel="prefetch" href="/assets/js/67.4c516a7e.js"><link rel="prefetch" href="/assets/js/68.0f32d032.js"><link rel="prefetch" href="/assets/js/69.bbd7d350.js"><link rel="prefetch" href="/assets/js/7.cae65080.js"><link rel="prefetch" href="/assets/js/70.c7e53812.js"><link rel="prefetch" href="/assets/js/71.19bef95e.js"><link rel="prefetch" href="/assets/js/72.8b1064b6.js"><link rel="prefetch" href="/assets/js/73.38f88a8c.js"><link rel="prefetch" href="/assets/js/74.25899472.js"><link rel="prefetch" href="/assets/js/75.ce232c94.js"><link rel="prefetch" href="/assets/js/76.c0a869a1.js"><link rel="prefetch" href="/assets/js/77.6d83c782.js"><link rel="prefetch" href="/assets/js/78.b6aa319e.js"><link rel="prefetch" href="/assets/js/79.453dab05.js"><link rel="prefetch" href="/assets/js/8.ed034e3d.js"><link rel="prefetch" href="/assets/js/80.53273be8.js"><link rel="prefetch" href="/assets/js/81.c2507ea0.js"><link rel="prefetch" href="/assets/js/82.6fe95e8a.js"><link rel="prefetch" href="/assets/js/83.d9b46c29.js"><link rel="prefetch" href="/assets/js/84.0de080f1.js"><link rel="prefetch" href="/assets/js/85.8a368f22.js"><link rel="prefetch" href="/assets/js/86.05d17637.js"><link rel="prefetch" href="/assets/js/87.79450de5.js"><link rel="prefetch" href="/assets/js/88.44e64585.js"><link rel="prefetch" href="/assets/js/89.382ba854.js"><link rel="prefetch" href="/assets/js/9.3ff4d901.js"><link rel="prefetch" href="/assets/js/90.ab31bd84.js"><link rel="prefetch" href="/assets/js/91.6061c3ac.js"><link rel="prefetch" href="/assets/js/92.b92e341c.js"><link rel="prefetch" href="/assets/js/93.64521dfc.js"><link rel="prefetch" href="/assets/js/94.eddc3251.js"><link rel="prefetch" href="/assets/js/95.7f7eeba5.js"><link rel="prefetch" href="/assets/js/96.ae9e13c6.js"><link rel="prefetch" href="/assets/js/97.6a5b9cfe.js"><link rel="prefetch" href="/assets/js/98.2ce3e203.js"><link rel="prefetch" href="/assets/js/99.50c33997.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d9c8cf8c.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Young's blog" class="logo"> <span class="site-name can-hide">Young's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Spring/" class="nav-link">Spring</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章1</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/andanyang/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.png"> <div class="blogger-info"><h3>Young</h3> <span></span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Spring/" class="nav-link">Spring</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章1</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/andanyang/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/mysql/MySQL_execution_process_and_execution_sequence/" class="sidebar-link">MySQL高级原理及优化第一篇：MySQL执行过程及执行顺序</a></li><li><a href="/mysql/mysql_InnoDB/" class="sidebar-link">MySQL高级原理及优化第二篇： Mysql存储引擎InnoDB介绍</a></li><li><a href="/mysql/mysql_index/" class="sidebar-link">MySQL高级原理及优化第三篇： MySQL索引原理</a></li><li><a href="/mysql/mysql_Transactions_locks/" class="sidebar-link">MySQL高级原理及优化第四篇： MySQL事务和锁</a></li><li><a href="/mysql/mysql_Cluster_architecture/" class="sidebar-link">MySQL高级原理及优化第五篇：MySQL集群架构</a></li><li><a href="/mysql/mysql_excel/" class="sidebar-link">excel百万数据如何导入导出</a></li><li><a href="/mysql/mysql_order_by/" class="sidebar-link">mysql order by 原理及优化详解</a></li><li><a href="/mysql/mysql_optimize/" class="sidebar-link">聊聊数据库优化的4大手段</a></li><li><a href="/mysql/Master_slave_replication_delay/" class="sidebar-link">高频面试：如何解决MySQL主从复制延时问题</a></li><li><a href="/mysql/index_all/" class="sidebar-link">1万字+30张图 对mysql索引概念以及原理全方位讲解</a></li><li><a href="/mysql/LEFT_JOIN_AND_JOIN/" class="sidebar-link">详解 Mysql LEFT JOIN和JOIN查询区别及原理</a></li><li><a href="/mysql/IN_Exist/" class="sidebar-link">MySQL IN、Exist关联查询时，我们为什么建议小表驱动大表？</a></li><li><a href="/mysql/Interview/" aria-current="page" class="active sidebar-link">面试官：MySQL连环炮，你扛得住嘛？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mysql/Interview_innodb_230720/" class="sidebar-link">InnoDB为什么不用跳表，Redis为什么不用B+树?</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/categories/?category=mysql" title="分类" data-v-06225672>mysql</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/andanyoung" target="_blank" title="作者" class="beLink" data-v-06225672>andanyang</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-06-19</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">面试官：MySQL连环炮，你扛得住嘛？<!----></h1>  <div class="theme-vdoing-content content__default"><h3 id="_1、三大范式"><a href="#_1、三大范式" class="header-anchor">#</a> 1、三大范式</h3> <p><strong>1NF(第一范式)</strong>：属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p> <p><strong>2NF(第二范式)</strong>：2NF 要求数据库表中的每个实例或行必须<strong>可以被惟一地区分</strong>，2NF 在 1NF 的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p> <p><strong>3NF(第三范式)</strong>：3NF 在 2NF 的基础之上，要求每列都和主键列直接相关，而不是间接相关，即不存在其他表的非主键信息。</p> <p>在开发过程中，并不一定要满足三大范式，有时候为了提高查询效率，可以在表中冗余其他表的字段。</p> <h3 id="_2、dml-语句和-ddl-语句区别"><a href="#_2、dml-语句和-ddl-语句区别" class="header-anchor">#</a> 2、DML 语句和 DDL 语句区别</h3> <ul><li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li> <li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li></ul> <h3 id="_3、主键和外键的区别"><a href="#_3、主键和外键的区别" class="header-anchor">#</a> 3、主键和外键的区别</h3> <ul><li><strong>主键</strong>：用于唯一标识一行数据，不能有重复，不允许为空，且一个表只能有一个主键；</li> <li><strong>外键</strong>：用来和其他表建立联系，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键；</li></ul> <h3 id="_4、drop、delete、truncate-区别"><a href="#_4、drop、delete、truncate-区别" class="header-anchor">#</a> 4、drop、delete、truncate 区别</h3> <p>（1）用法不同</p> <ul><li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表结构都删除掉，在删除表的时候使用。</li> <li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li> <li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li></ul> <p>（2）属于不同的数据库语言</p> <ul><li><code>truncate</code> 和 <code>drop</code> 属于 DDL(数据定义语言) 语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</li> <li><code>delete</code> 语句是 DML (数据库操作语言) 语句，这个操作会放到 rollback segment 中，事务提交之后才生效。</li></ul> <p>（3）执行速度不同</p> <ul><li><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li> <li><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li> <li><code>drop</code>命令会把表占用的空间全部释放掉。</li></ul> <p>一般来说：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code></p> <h3 id="_5、基础架构"><a href="#_5、基础架构" class="header-anchor">#</a> 5、基础架构</h3> <p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p> <p><img src="/assets/img/640-1212121wdada.98899e8e.png" alt=""></p> <ul><li><strong>连接器：</strong> 身份认证和权限相关 (登录 MySQL 的时候)。</li> <li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li> <li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li> <li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li> <li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li> <li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul> <h3 id="_6、myisam-和-innodb-有什么区别"><a href="#_6、myisam-和-innodb-有什么区别" class="header-anchor">#</a> 6、MyISAM 和 InnoDB 有什么区别？</h3> <p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p> <p><strong>（1）是否支持行级锁</strong></p> <p>MyISAM 只有表级锁，而 InnoDB 支持行级锁和表级锁，默认为行级锁。</p> <p><strong>（2）是否支持事务</strong></p> <p>MyISAM 不提供事务支持，InnoDB 提供事务支持，实现了 SQL 标准定义的四个隔离级别，具有提交和回滚事务的能力。</p> <p>InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p> <p><strong>（3）是否支持外键</strong></p> <p>MyISAM 不支持，而 InnoDB 支持。</p> <p><strong>（4）是否支持数据库异常崩溃后的安全恢复</strong></p> <p>MyISAM 不支持，而 InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p> <p><strong>（5）是否支持 MVCC</strong></p> <p>MyISAM 不支持，而 InnoDB 支持。</p> <p><strong>（6）索引实现</strong></p> <p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p> <ul><li>InnoDB 引擎中，其数据文件本身就是索引文件。其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶子节点 data 域保存了完整的数据记录。</li> <li>MyISAM 索引文件和数据文件是分离的，索引保存的是数据文件的指针。</li></ul> <p><strong>（7）性能差别</strong></p> <p>InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。</p> <p><img src="/assets/img/640-1687161030104-1.a71361b5.png" alt=""></p> <p>InnoDB 和 MyISAM 性能对比</p> <h3 id="_7、推荐自增-id-作为主键问题"><a href="#_7、推荐自增-id-作为主键问题" class="header-anchor">#</a> 7、推荐自增 id 作为主键问题</h3> <ul><li>普通索引的 B+ 树上存放的是主键索引的值，如果该值较大，会**「导致普通索引的存储空间较大」**</li> <li>使用自增 id 做主键索引新插入数据只要放在该页的最尾端就可以，直接**「按照顺序插入」**，不用刻意维护</li> <li>页分裂容易维护，当插入数据的当前页快满时，会发生页分裂的现象，如果主键索引不为自增 id，那么数据就可能从页的中间插入，页的数据会频繁的变动，<strong>「导致页分裂维护成本较高」</strong></li></ul> <h3 id="_8、为什么-mysql-的自增主键不连续"><a href="#_8、为什么-mysql-的自增主键不连续" class="header-anchor">#</a> 8、为什么 MySQL 的自增主键不连续</h3> <ul><li>在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化；</li> <li>唯一键冲突：插入数据时先将自增主键 + 1，然后插入数据时唯一键冲突，插入数据失败，但是未将自增主键改回；</li> <li>事务回滚：和唯一键冲突类似，回滚操作时自增值也不回退，事实上，这么做的主要原因是为了提高性能。</li></ul> <h3 id="_9、redo-log-是做什么的"><a href="#_9、redo-log-是做什么的" class="header-anchor">#</a> 9、redo log 是做什么的?</h3> <p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p> <p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p> <p>更新表数据的时候，如果发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。然后会把 “在某个数据页上做了什么修改” 记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p> <h3 id="_10、redo-log-的刷盘时机"><a href="#_10、redo-log-的刷盘时机" class="header-anchor">#</a> 10、redo log 的刷盘时机</h3> <p><img src="/assets/img/640-1687161030105-2.937e4c71.png" alt=""></p> <ul><li>红色部分为 redo log buffer 属于内存</li> <li>黄色部分为 page cache ，此时已经写入磁盘了，但是未进行持久化</li> <li>绿色部分是硬盘，已经完成持久化</li></ul> <p>InnoDB 存储引擎为 redo log 的刷盘策略提供了 innodb_flush_log_at_trx_commit 参数，它支持<strong>三种策略</strong></p> <ul><li>设置为 0 的时候，表示每次事务提交时<strong>不进行刷盘</strong>操作，只是保留在 redo log buffer 中，mysql 崩溃会丢失 1s 的数据；</li> <li>设置为 1 的时候，表示每次事务提交时<strong>都将进行</strong>刷盘操作（默认值），持久化到磁盘；</li> <li>设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 <strong>page cache</strong>，OS 宕机会丢失 1s 的数据，因为未进行持久化；</li></ul> <p>innodb_flush_log_at_trx_commit 参数默认为 1 ，也就是说当事务提交时会调用 fsync(同步操作) 对 redo log 进行刷盘。</p> <p>另外 InnoDB 存储引擎有一个后台<strong>线程</strong>，每隔 1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。</p> <p>redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。</p> <h3 id="_11、redo-log-是怎么记录日志的"><a href="#_11、redo-log-是怎么记录日志的" class="header-anchor">#</a> 11、redo log 是怎么记录日志的</h3> <p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p> <p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p> <p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p> <p><img src="/assets/img/640-1687161030105-3.321f2bcc.png" alt=""></p> <p>所以，如果数据写满了但是还没有来得及将数据真正的刷入磁盘当中，那么就会发生**「内存抖动」**现象，从肉眼的角度来观察会发现 mysql 会宕机一会儿，此时就是正在刷盘了。</p> <h3 id="_12、什么是-binlog"><a href="#_12、什么是-binlog" class="header-anchor">#</a> 12、什么是 binlog</h3> <p>binlog 是归档日志，属于 Server 层的日志，是一个二进制格式的文件，记录内容是语句的原始逻辑，类似于 “给 ID=2 这一行的 c 字段加 1”。</p> <p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。它的主要作用就是数据备份、主从复制。</p> <p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，属于逻辑日志，并且是顺序写。</p> <h3 id="_13、binlog-记录格式"><a href="#_13、binlog-记录格式" class="header-anchor">#</a> 13、binlog 记录格式</h3> <p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p> <ul><li><strong>statement</strong> ：记录的内容是<code>SQL</code>语句原文，存在数据一致性问题；</li> <li><strong>row</strong>：记录包含操作的具体数据，能保证同步数据的一致性；</li> <li><strong>mixed</strong>：记录的内容是前两者的混合，<code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致：如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</li></ul> <h3 id="_14、binlog-写入机制"><a href="#_14、binlog-写入机制" class="header-anchor">#</a> 14、binlog 写入机制</h3> <p>事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p> <p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p> <p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p> <p>binlog 也提供了 sync_binlog 参数来控制写入 page cache 和磁盘的时机：</p> <ul><li>0：每次提交事务都只写入到文件系统的 page cache，由系统自行判断什么时候执行<code>fsync</code>，机器宕机，<code>page cache</code>里面的 binlog 会丢失。</li> <li>1：每次提交事务都会执行<code>fsync</code>，就如同 <strong>redo log 日志刷盘流程</strong> 一样。</li> <li>N(N&gt;1)：每次提交事务都写入到文件系统的 page cache，但累积<code>N</code>个事务后才<code>fsync</code>。如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志。</li></ul> <h3 id="_15、redolog-和-binlog-的区别是什么"><a href="#_15、redolog-和-binlog-的区别是什么" class="header-anchor">#</a> 15、redolog 和 binlog 的区别是什么</h3> <ul><li><strong>redolog</strong> 是 <strong>Innodb</strong> 独有的日志，而 <strong>binlog</strong> 是 <strong>server</strong> 层的，所有的存储引擎都有使用到；</li> <li><strong>redolog</strong> 记录了<strong>具体的数值</strong>，对某个页做了什么修改，<strong>binlog</strong> 记录的<strong>操作内容</strong>；</li> <li><strong>binlog</strong> 大小达到上限或者 flush log <strong>会生成一个新的文件</strong>，而 <strong>redolog</strong> 有固定大小<strong>只能循环利用</strong>；</li> <li><strong>binlog 日志没有 crash-safe 的能力</strong>，只能用于归档，而 redo log 有 crash-safe 能力；</li> <li><strong>redo log</strong> 在事务执行过程中可以不断写入（刷盘设置为 1，后台线程 1s 执行一次或者 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候），而 binlog 只有在提交事务时才写入文件缓存系统；</li></ul> <h3 id="_16、两阶段提交"><a href="#_16、两阶段提交" class="header-anchor">#</a> 16、两阶段提交</h3> <p>假设执行 sql 过程中写完 redo log 日志后，binlog 日志写期间发生了异常，会出现什么情况呢？</p> <p>由于 binlog 没写完就异常，这时候 binlog 里面没有对应的修改记录。因此，之后用 binlog 日志恢复数据时，就会少这一次更新，<strong>最终数据不一致</strong>。</p> <p>为了解决两份日志之间的逻辑一致问题，InnoDB 存储引擎使用<strong>两阶段提交</strong>方案。</p> <p>将 redo log 的写入拆成了两个步骤 prepare 和 commit，这就是两阶段提交。使用两阶段提交后，写入 binlog 时发生异常也不会有影响，因为 MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog 日志，就会回滚该事务。</p> <p>再看一个场景，redo log 设置 commit 阶段发生异常，那会不会回滚事务呢？</p> <p>并不会回滚事务，虽然 redo log 是处于 prepare 阶段，但是能通过事务 id 找到对应的 binlog 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。</p> <h3 id="_17、什么是-undo-log"><a href="#_17、什么是-undo-log" class="header-anchor">#</a> 17、什么是 undo log</h3> <p>我们知道如果想要<strong>保证事务的原子性</strong>，就需要在异常发生时，对已经执行的操作（INSERT、DELETE、UPDATE）进行回滚，在 MySQL 中，恢复机制是通过回滚日志（undo log） 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。</p> <p>每次对记录进行改动都会记录一条 undo log，每条 undo log 也都有一个<code>DB_ROLL_PTR</code>属性，可以将这些 undo log 都连起来，串成一个链表，形成版本链。</p> <p>版本链的头节点就是当前记录最新的值。</p> <p><img src="/assets/img/640-1687161030105-4.4569c0ad.png" alt=""></p> <h3 id="_18、什么是-relaylog"><a href="#_18、什么是-relaylog" class="header-anchor">#</a> 18、什么是 relaylog</h3> <p>relaylog 是中继日志，<strong>在主从同步的时候使用到</strong>，它是一个中介临时的日志文件，用于存储从 master 节点同步过来的 binlog 日志内容。</p> <p><img src="/assets/img/640-1687161030106-5.aa3f5a3a.png" alt=""></p> <p>master 主节点的 binlog 传到 slave 从节点后，被写入 relay log 里，从节点的 slave sql 线程从 relaylog 里读取日志然后应用到 slave 从节点本地。</p> <p>从服务器 I/O 线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后 SQL 线程会读取 relay-log 日志的内容并应用到从服务器，从而<strong>使从服务器和主服务器的数据保持一致</strong>。</p> <h3 id="_19、索引"><a href="#_19、索引" class="header-anchor">#</a> 19、索引</h3> <p>索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据。</p> <p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p> <h3 id="_20、hash-索引"><a href="#_20、hash-索引" class="header-anchor">#</a> 20、Hash 索引</h3> <p>哈希表是键值对的集合，通过键 (key) 即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p> <p>但是！哈希算法有个 Hash 冲突问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。</p> <p>链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 HashMap 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后 HashMap 为了减少链表过长的时候搜索时间过长引入了红黑树。</p> <p>为了减少 Hash 冲突的发生，一个好的哈希函数应该 “均匀地” 将数据分布在整个可能的哈希值集合中。</p> <p><strong>既然哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？</strong> 主要是因为 Hash 索引<strong>不支持顺序和范围查询</strong>。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了，并且每次 IO 只能取一个。</p> <h3 id="_21、b-树和-b-树"><a href="#_21、b-树和-b-树" class="header-anchor">#</a> 21、B 树和 B+ 树</h3> <ul><li>B 树的所有节点既存放键 (key) 也存放数据 (data)，而 B + 树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li> <li>B 树的叶子节点都是独立的；B + 树的叶子节点有一条引用链指向与它相邻的叶子节点。</li> <li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B + 树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul> <h3 id="_22、主键索引"><a href="#_22、主键索引" class="header-anchor">#</a> 22、主键索引</h3> <p>数据表的主键列使用的就是主键索引，一种特殊的唯一索引。</p> <p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p> <h3 id="_23、二级索引"><a href="#_23、二级索引" class="header-anchor">#</a> 23、二级索引</h3> <p>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</p> <p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p> <ul><li>唯一索引 (Unique Key) ：唯一索引也是一种约束。索引列的值必须唯一，但允许有空值；如果是<strong>组合索引</strong>，则列值的组合必须唯一。一张表允许创建多个唯一索引。建立唯一索引的目的大部分时候都是为了该属性列的<strong>数据的唯一性，而不是为了查询效率</strong>。</li> <li>普通索引 (Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li> <li>前缀索引 (Prefix) ：前缀索引只适用于<strong>字符串</strong>类型的数据。前缀索引是对<strong>文本的前几个字符创建索引</strong>，相比普通索引建立的数据更小， 因为只取前几个字符。</li> <li>组合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循<strong>最左前缀集合</strong>（后文介绍）；</li> <li>全文索引 (Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ul> <blockquote><p>MySQL 中的全文索引，有两个变量，<strong>最小搜索长度和最大搜索长度</strong>，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。</p></blockquote> <h3 id="_24、聚簇索引与非聚簇索引"><a href="#_24、聚簇索引与非聚簇索引" class="header-anchor">#</a> 24、聚簇索引与非聚簇索引</h3> <p>聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 的主键索引的叶子节点中存放的就是数据行，所以它属于聚簇索引。</p> <p>在 MySQL 中，InnoDB 引擎的表的 .ibd 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引 (B + 树) 的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p> <p>非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引 (辅助索引) 就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p> <p>辅助索引是我们人为创建的索引，它的叶子节点中存放的是主键，当我们通过辅助索引查找到主键之后，再通过查找的主键去<strong>回表</strong>查找主键索引。</p> <h3 id="_25、回表"><a href="#_25、回表" class="header-anchor">#</a> 25、回表</h3> <p>回表就是先通过数据库索引扫描出该索引树中数据所在的行，取到主键 id，再通过主键 id 取出主键索引数中的数据，即基于非主键索引的查询需要多扫描一棵索引树。</p> <h3 id="_26、覆盖索引和联合索引"><a href="#_26、覆盖索引和联合索引" class="header-anchor">#</a> 26、覆盖索引和联合索引</h3> <p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 “覆盖索引”。指的是通过索引就能查询到我们所需要的数据，而不需要根据索引再去查询数据表中的数据（ 回表），这样就减少了数据库的 io 操作，提高查询效率。</p> <p>使用表中的多个字段创建索引，就是联合索引，也叫组合索引或复合索引。</p> <h3 id="_27、最左前缀匹配原则"><a href="#_27、最左前缀匹配原则" class="header-anchor">#</a> 27、最左前缀匹配原则</h3> <p>最左前缀匹配原则指的是在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，<strong>直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 &gt;、&lt;、between 和 以 % 开头的 like 查询 等条件，才会停止匹配。</strong></p> <p>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p> <h3 id="_28、索引下推"><a href="#_28、索引下推" class="header-anchor">#</a> 28、索引下推</h3> <p>索引下推（Index Condition Pushdown） 是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p> <h3 id="_29、隐式转换"><a href="#_29、隐式转换" class="header-anchor">#</a> 29、隐式转换</h3> <p>当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。例如，MySQL 会根据需要自动将字符串转换为数字，反之亦然。以下规则描述了比较操作的转换方式：</p> <ol><li>两个参数至少有一个是 NULL 时，比较的结果也是 NULL，特殊的情况是使用 &lt;=&gt; 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换；</li> <li>两个参数都是字符串，会按照字符串来比较，不做类型转换；</li> <li>两个参数都是整数，按照整数来比较，不做类型转换；</li> <li>十六进制的值和非数字做比较时，会被当做二进制串；</li> <li>有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp；</li> <li>有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较；</li> <li>所有其他情况下，两个参数都会被转换为浮点数再进行比较；</li></ol> <h3 id="_30、普通索引和唯一索引该怎么选择"><a href="#_30、普通索引和唯一索引该怎么选择" class="header-anchor">#</a> 30、普通索引和唯一索引该怎么选择?</h3> <ul><li><p>查询</p> <ul><li><p>当普通索引为条件时查询到数据会一直扫描，直到扫完整张表；</p></li> <li><p>当唯一索引为查询条件时，查到该数据会直接返回，不会继续扫表；</p></li></ul></li> <li><p>更新</p> <ul><li><p>普通索引会直接将操作更新到 change buffer 中，然后结束</p></li> <li><p>唯一索引需要判断数据是否冲突</p></li></ul></li></ul> <p>所以<strong>唯一索引更加适合查询的场景，普通索引更适合插入的场景。</strong></p> <h3 id="_31、避免索引失效"><a href="#_31、避免索引失效" class="header-anchor">#</a> 31、避免索引失效</h3> <p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p> <ul><li>使用 SELECT * 进行查询;</li> <li>创建了组合索引，但查询条件未准守最左匹配原则;</li> <li>在索引列上进行计算、函数、类型转换等操作;</li> <li>以 % 开头的 LIKE 查询比如 like '%abc';</li> <li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到</li> <li>match() 函数中的指定的列必须与全文索引中指定的列完全相同，否则会报错，无法使用全文索引。</li> <li>全文索引时要注意搜索长度会导致索引失效</li></ul> <h3 id="_32、建立索引的规则"><a href="#_32、建立索引的规则" class="header-anchor">#</a> 32、建立索引的规则</h3> <ul><li>不为 NULL 的字段 ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li> <li>被频繁查询的字段 ：我们创建索引的字段应该是查询操作非常频繁的字段。</li> <li>被作为条件查询的字段 ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li> <li>频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li> <li>被经常频繁用于连接的字段 ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段可以考虑建立索引，提高多表连接查询的效率。</li> <li>被频繁更新的字段应该慎重建立索引；</li> <li>尽可能的考虑建立联合索引而不是单列索引；</li> <li>考虑在字符串类型的字段上使用前缀索引代替普通索引；</li> <li>删除长期未使用的索引；</li></ul> <h3 id="_33、事务极其特性"><a href="#_33、事务极其特性" class="header-anchor">#</a> 33、事务极其特性</h3> <p>一个事情由 n 个单元组成，这 n 个单元在执行过程中，要么同时成功，要么同时失败，这就把 n 个单元放在了一个事务之中。举个简单的例子：在不考虑试题正确与否的前提下，一张试卷由多个题目构成，当你答完题交给老师的时候是将一整张试卷交给老师，而不是将每道题单独交给老师，在这里试卷就可以理解成一个事务。</p> <p>事务的特性：</p> <ul><li>A：原子性（<code>Atomicity</code>），原子性是指事务是一个不可分割的工作单位，事务中的操作，要么都发生，要么都不发生。</li> <li>C：一致性（<code>Consistency</code>），在一个事务中，事务前后数据的完整性必须保持一致。</li> <li>I：隔离性（<code>Isolation</code>），存在于多个事务中，事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。</li> <li>D：持久性（<code>Durability</code>），持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul> <h3 id="_34、并发事务带来的问题"><a href="#_34、并发事务带来的问题" class="header-anchor">#</a> 34、并发事务带来的问题</h3> <ul><li>脏读（Dirty read）：B 事务读取到了 A 事务尚未提交的数据；</li> <li>丢失修改（Lost to modify）：在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</li> <li>不可重复读（Unrepeatable read）：B 事务读到了 A 事务已经提交的数据，即 B 事务在 A 事务提交之前和提交之后读取到的数据<code>内容</code>不一致（AB 事务操作的是同一条数据）；</li> <li>幻读 / 虚读：B 事务读到了 A 事务已经提交的数据，即 A 事务执行插入操作，B 事务在 A 事务前后读到的数据<code>数量</code>不一致。</li></ul> <h3 id="_35、事务的隔离级别"><a href="#_35、事务的隔离级别" class="header-anchor">#</a> 35、事务的隔离级别</h3> <p>为了解决以上隔离性引发的并发问题，数据库提供了事务的隔离机制。</p> <ul><li>read uncommitted（读未提交）: 一个事务还没提交时，它做的变更就能被别的事务看到，读取尚未提交的数据，哪个问题都不能解决；</li> <li>read committed（读已提交）：一个事务提交之后，它做的变更才会被其他事务看到，读取已经提交的数据，可以解决脏读 ---- oracle 默认的；</li> <li>repeatable read（可重复读）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的，可以解决脏读和不可重复读 ---mysql 默认的；</li> <li>serializable（串行化）：顾名思义是对于同一行记录，“写”会加 “写锁”，“读” 会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。可以解决脏读、不可重复读和虚读 --- 相当于锁表。</li></ul> <p>虽然 serializable 级别可以解决所有的数据库并发问题，但是它会在读取的每一行数据上都加锁，这就可能导致大量的超时和锁竞争问题，从而导致效率下降。所以我们在实际应用中也很少使用 serializable，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。</p> <h3 id="_36、mvcc"><a href="#_36、mvcc" class="header-anchor">#</a> 36、MVCC</h3> <p>锁的粒度过大会导致性能的下降， MySQL 的 InnoDB 引擎下存在一种性能更优越的 MVCC 方法。</p> <p>MVCC 是 <code>Multi-Version Concurremt Control</code> 的简称，<strong>意思是基于多版本的并发控制协议，通过版本号避免同一数据在不同事务间的竞争</strong>。它主要是为了提高数据库的并发读写性能，不用加锁就能让多个事务并发读写。</p> <p>MVCC 的实现依赖于<strong>隐藏列、Undo log、 Read View</strong> 。</p> <p>从上面对 SQL 标准定义了四个隔离级别的介绍可以看出，<strong>标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读) 是不可以防止幻读的</strong>。</p> <p>但是 InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p> <ul><li>快照读 ：由 MVCC 机制来保证不出现幻读。</li> <li>当前读 ：使用 Next-Key Lock（临键锁） 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li></ul> <blockquote><p>InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。</p></blockquote> <h3 id="_37、mysql-中的锁"><a href="#_37、mysql-中的锁" class="header-anchor">#</a> 37、Mysql 中的锁</h3> <p>具体的锁详情请参考<a href="/mysql/mysql_Transactions_locks">此篇文章</a>：面试必备常见存储引擎与锁的分类，请查收</p> <h3 id="_38、查询语句执行过程"><a href="#_38、查询语句执行过程" class="header-anchor">#</a> 38、查询语句执行过程</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>select * from tb_student  s where s.age='18' and s.name=' 张三 ';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</li> <li>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li> <li>接下来就是优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：</li> <li>a. 先查询学生表中姓名为 “张三” 的学生，然后判断是否年龄是 18。</li> <li>b. 先找出学生中年龄 18 岁的学生，然后再查询姓名为 “张三” 的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</li> <li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</li></ul> <p>查询语句的执行流程如下：权限校验（如果命中缓存）---&gt; 查询缓存 ---&gt; 分析器 ---&gt; 优化器 ---&gt; 权限校验 ---&gt; 执行器 ---&gt; 引擎</p> <h3 id="_39、更新语句执行过程"><a href="#_39、更新语句执行过程" class="header-anchor">#</a> 39、更新语句执行过程</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>update tb_student A set A.age='19' where A.name=' 张三 ';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这条语句基本上也会沿着上一个查询的流程走，只不过执行更新的时候要记录日志，这就会引入日志模块了，MySQL 自带的日志模块是 binlog（归档日志） ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 redo log（重做日志），我们就以 InnoDB 模式下来探讨这个语句的执行流程。</p> <ul><li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li> <li>然后拿到查询的语句把 age 改为 19，然后调用引擎 API 接口写入这一行数据，InnoDB 引擎把数据保存在内存中同时记录 redo log，此时 redo log <strong>进入 prepare 状态</strong>，然后告诉执行器执行完成了随时可以提交。</li> <li>执行器收到通知后记录 binlog，然后调用引擎接口，<strong>提交 redo log 为提交状态</strong>。</li> <li>更新完成。</li></ul> <p>更新语句执行流程如下：分析器 ----&gt; 权限校验 ----&gt; 执行器 ---&gt; 引擎 ---redo log(prepare 状态)---&gt; binlog ---&gt;redo log(commit 状态)</p> <h3 id="_40、sql-优化"><a href="#_40、sql-优化" class="header-anchor">#</a> 40、sql 优化</h3> <ol><li>应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引；</li> <li>应尽量避免在 where 子句中使用以下语句，否则将导致引擎放弃使用索引而进行全表扫描；</li></ol> <ul><li>对字段进行 null 值判断，</li> <li>使用!= 或 &lt;&gt;</li> <li>or 来连接条件（使用 union all 代替）</li> <li>in 和 not in 也要慎用</li> <li>不要使用模糊查询（可用全文索引）</li> <li>减少表达式操作</li> <li>函数操作</li></ul> <ol start="4"><li>任何地方都不要使用 select _ from t ，用具体的字段列表代替 “_”，不要返回用不到的任何字段；</li> <li>一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要；</li> <li>很多时候用 exists 代替 in 是一个好的选择；</li> <li>尽量减少多表联合查询；</li> <li>分页优化；</li> <li>正确使用索引；</li></ol> <h3 id="_41、主从同步数据"><a href="#_41、主从同步数据" class="header-anchor">#</a> 41、主从同步数据</h3> <p><img src="/assets/img/640-1687161030106-6.3e215de8.png" alt=""></p> <ul><li>master 主库将此次更新的事件类型<strong>写入到主库的 binlog 文件</strong>中</li> <li>master <strong>创建 log dump 线程通知 slave</strong> 需要更新数据</li> <li><strong>slave</strong> 向 master 节点发送请求，<strong>将该 binlog 文件内容存到本地的 relaylog 中</strong></li> <li><strong>slave 开启 sql 线程</strong>读取 relaylog 中的内容，<strong>将其中的内容在本地重新执行一遍</strong>，完成主从数据同步</li></ul> <p><strong>同步策略</strong>：</p> <ul><li><strong>全同步复制</strong>：主库强制同步日志到从库，等全部从库执行完才返回客户端，性能差；</li> <li><strong>半同步复制</strong>：主库收到至少一个从库确认就认为操作成功，从库写入日志成功返回 ack 确认；</li></ul> <h3 id="_42、主从延迟要怎么解决"><a href="#_42、主从延迟要怎么解决" class="header-anchor">#</a> 42、主从延迟要怎么解决</h3> <ul><li>MySQL 5.6 版本以后，提供了一种<strong>并行复制</strong>的方式，通过将 SQL 线程转换为多个 work 线程来进行重放</li> <li><strong>提高机器配置</strong> (王道)</li> <li>在业务初期就选择合适的分库、分表策略，<strong>避免单表单库过大</strong>带来额外的复制压力</li> <li><strong>避免长事务</strong></li> <li><strong>避免让数据库进行各种大量运算</strong></li> <li>对于一些对延迟很敏感的业务<strong>直接使用主库读</strong></li></ul> <h3 id="_43、为什么不要使用长事务"><a href="#_43、为什么不要使用长事务" class="header-anchor">#</a> 43、为什么不要使用长事务</h3> <ul><li>并发情况下，数据库<strong>连接池容易被撑爆</strong></li> <li><strong>容易造成大量的阻塞和锁超时</strong>，长事务还占用锁资源，也可能拖垮整个库</li> <li>执行时间长，容易造成<strong>主从延迟</strong></li> <li><strong>回滚所需要的时间比较长</strong>，事务越长整个时间段内的事务也就越多</li> <li><strong>undolog 日志越来越大</strong>，长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/andanyang/vuepress-theme-vdoing/edit/master/docs/mysql/02001.mysql面试.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/08/03, 08:18:11</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/mysql/IN_Exist/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">MySQL IN、Exist关联查询时，我们为什么建议小表驱动大表？</div></a> <a href="/mysql/Interview_innodb_230720/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">InnoDB为什么不用跳表，Redis为什么不用B+树?</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/mysql/IN_Exist/" class="prev">MySQL IN、Exist关联查询时，我们为什么建议小表驱动大表？</a></span> <span class="next"><a href="/mysql/Interview_innodb_230720/">InnoDB为什么不用跳表，Redis为什么不用B+树?</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/digitalization/详谈装备制造业MES系统功能以及实施要点/"><div>
            详谈装备制造业MES系统功能以及实施要点
            <!----></div></a> <span class="date">07-14</span></dt></dl><dl><dd>02</dd> <dt><a href="/digitalization/MES生产过程控制：实现智能工厂的关键/"><div>
            扩展阅读-MES生产过程控制：实现智能工厂的关键
            <!----></div></a> <span class="date">07-14</span></dt></dl><dl><dd>03</dd> <dt><a href="/digitalization/DX_technology_business/"><div>
            数字化转型的核心是技术？还是业务？
            <!----></div></a> <span class="date">07-13</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1218853253@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/andanyang" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2023
    <span>Young | <a href="https://github.com/andanyoung/young-blog/blob/master/LICENSE" target="_blank">MIT License</a> <br/> <a  href="https://beian.miit.gov.cn/" target="_blank">浙ICP备20002744号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.47dc12bc.js" defer></script><script src="/assets/js/2.3e7974e5.js" defer></script><script src="/assets/js/32.d4d0d436.js" defer></script>
  </body>
</html>
