<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>万字总结Zookeeper客户端Curator操作Api | Young&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="Young丶java后端技术博客,专注后端学习与总结。擅长spring boot,JAVA基础总结,等方面的知识,关注spring,架构,elasticsearch,mysql领域.">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.1cda4d67.css" as="style"><link rel="preload" href="/assets/js/app.450efd07.js" as="script"><link rel="preload" href="/assets/js/2.7973be65.js" as="script"><link rel="preload" href="/assets/js/112.eb871c6e.js" as="script"><link rel="prefetch" href="/assets/js/10.b9632c9a.js"><link rel="prefetch" href="/assets/js/100.3ee3bca4.js"><link rel="prefetch" href="/assets/js/101.732e8543.js"><link rel="prefetch" href="/assets/js/102.c212e198.js"><link rel="prefetch" href="/assets/js/103.1e320f78.js"><link rel="prefetch" href="/assets/js/104.3d89ee11.js"><link rel="prefetch" href="/assets/js/105.26c60bae.js"><link rel="prefetch" href="/assets/js/106.c89a882a.js"><link rel="prefetch" href="/assets/js/107.3933c03c.js"><link rel="prefetch" href="/assets/js/108.b23938f0.js"><link rel="prefetch" href="/assets/js/109.8f57665e.js"><link rel="prefetch" href="/assets/js/11.4d1e11c5.js"><link rel="prefetch" href="/assets/js/110.bfc1e548.js"><link rel="prefetch" href="/assets/js/111.af28376c.js"><link rel="prefetch" href="/assets/js/113.d6437f7c.js"><link rel="prefetch" href="/assets/js/114.75b44316.js"><link rel="prefetch" href="/assets/js/115.ee506975.js"><link rel="prefetch" href="/assets/js/116.8740149c.js"><link rel="prefetch" href="/assets/js/117.e74b3d62.js"><link rel="prefetch" href="/assets/js/118.3c9d50da.js"><link rel="prefetch" href="/assets/js/119.09be1abe.js"><link rel="prefetch" href="/assets/js/12.9935542b.js"><link rel="prefetch" href="/assets/js/120.779556cd.js"><link rel="prefetch" href="/assets/js/121.b3053508.js"><link rel="prefetch" href="/assets/js/122.e07e6d3a.js"><link rel="prefetch" href="/assets/js/123.607abe00.js"><link rel="prefetch" href="/assets/js/124.acf1802a.js"><link rel="prefetch" href="/assets/js/125.5f315f90.js"><link rel="prefetch" href="/assets/js/126.2ad9aab0.js"><link rel="prefetch" href="/assets/js/127.f8d75261.js"><link rel="prefetch" href="/assets/js/128.706e33a0.js"><link rel="prefetch" href="/assets/js/129.1795c27f.js"><link rel="prefetch" href="/assets/js/13.1a76a8a8.js"><link rel="prefetch" href="/assets/js/130.5ce555c9.js"><link rel="prefetch" href="/assets/js/131.e3932a13.js"><link rel="prefetch" href="/assets/js/132.df44345a.js"><link rel="prefetch" href="/assets/js/133.3f52ee06.js"><link rel="prefetch" href="/assets/js/134.ff753014.js"><link rel="prefetch" href="/assets/js/135.b44dea53.js"><link rel="prefetch" href="/assets/js/136.362b3d19.js"><link rel="prefetch" href="/assets/js/137.7ce3d7bb.js"><link rel="prefetch" href="/assets/js/138.69419a3f.js"><link rel="prefetch" href="/assets/js/139.4cd928a3.js"><link rel="prefetch" href="/assets/js/14.e11c3fa8.js"><link rel="prefetch" href="/assets/js/140.28d89c98.js"><link rel="prefetch" href="/assets/js/141.47f396e9.js"><link rel="prefetch" href="/assets/js/142.3f263169.js"><link rel="prefetch" href="/assets/js/143.cee7d9a9.js"><link rel="prefetch" href="/assets/js/144.5f3b0df7.js"><link rel="prefetch" href="/assets/js/145.66174ff4.js"><link rel="prefetch" href="/assets/js/146.2c4148b8.js"><link rel="prefetch" href="/assets/js/147.bf0cc6f9.js"><link rel="prefetch" href="/assets/js/148.20d7addc.js"><link rel="prefetch" href="/assets/js/149.8633f572.js"><link rel="prefetch" href="/assets/js/15.9db97fb9.js"><link rel="prefetch" href="/assets/js/150.c669a395.js"><link rel="prefetch" href="/assets/js/151.a0edbc25.js"><link rel="prefetch" href="/assets/js/152.625a8b5b.js"><link rel="prefetch" href="/assets/js/153.c4568634.js"><link rel="prefetch" href="/assets/js/154.88891221.js"><link rel="prefetch" href="/assets/js/155.b29c2106.js"><link rel="prefetch" href="/assets/js/156.6c245600.js"><link rel="prefetch" href="/assets/js/157.b113ced0.js"><link rel="prefetch" href="/assets/js/16.2c8cb959.js"><link rel="prefetch" href="/assets/js/17.e691db6f.js"><link rel="prefetch" href="/assets/js/18.ad439d26.js"><link rel="prefetch" href="/assets/js/19.1bacc881.js"><link rel="prefetch" href="/assets/js/20.f44d1cb9.js"><link rel="prefetch" href="/assets/js/21.d786091c.js"><link rel="prefetch" href="/assets/js/22.649b4125.js"><link rel="prefetch" href="/assets/js/23.79946d9f.js"><link rel="prefetch" href="/assets/js/24.d97697de.js"><link rel="prefetch" href="/assets/js/25.365fc21d.js"><link rel="prefetch" href="/assets/js/26.eef14c6a.js"><link rel="prefetch" href="/assets/js/27.4757d362.js"><link rel="prefetch" href="/assets/js/28.4c1c1bb5.js"><link rel="prefetch" href="/assets/js/29.32154bb9.js"><link rel="prefetch" href="/assets/js/3.88e6e9f4.js"><link rel="prefetch" href="/assets/js/30.c4f4da04.js"><link rel="prefetch" href="/assets/js/31.09fa5c89.js"><link rel="prefetch" href="/assets/js/32.9f32e075.js"><link rel="prefetch" href="/assets/js/33.bda0728e.js"><link rel="prefetch" href="/assets/js/34.16cf77c9.js"><link rel="prefetch" href="/assets/js/35.f623bda2.js"><link rel="prefetch" href="/assets/js/36.37c6ab7c.js"><link rel="prefetch" href="/assets/js/37.e581391d.js"><link rel="prefetch" href="/assets/js/38.89393a5d.js"><link rel="prefetch" href="/assets/js/39.f4616603.js"><link rel="prefetch" href="/assets/js/4.db95c6a3.js"><link rel="prefetch" href="/assets/js/40.7884a8d8.js"><link rel="prefetch" href="/assets/js/41.1c276c6a.js"><link rel="prefetch" href="/assets/js/42.298b237c.js"><link rel="prefetch" href="/assets/js/43.688efd0b.js"><link rel="prefetch" href="/assets/js/44.7c1c47dd.js"><link rel="prefetch" href="/assets/js/45.aa472d5d.js"><link rel="prefetch" href="/assets/js/46.3f6c50d2.js"><link rel="prefetch" href="/assets/js/47.6bf929d7.js"><link rel="prefetch" href="/assets/js/48.d305a8c7.js"><link rel="prefetch" href="/assets/js/49.af838ca4.js"><link rel="prefetch" href="/assets/js/5.785a5118.js"><link rel="prefetch" href="/assets/js/50.7038ec1e.js"><link rel="prefetch" href="/assets/js/51.d52ec0e9.js"><link rel="prefetch" href="/assets/js/52.7360cfaa.js"><link rel="prefetch" href="/assets/js/53.314ac165.js"><link rel="prefetch" href="/assets/js/54.1f9029fd.js"><link rel="prefetch" href="/assets/js/55.a251de4e.js"><link rel="prefetch" href="/assets/js/56.b55f61ca.js"><link rel="prefetch" href="/assets/js/57.732f2888.js"><link rel="prefetch" href="/assets/js/58.8be35e40.js"><link rel="prefetch" href="/assets/js/59.c134d453.js"><link rel="prefetch" href="/assets/js/6.4de41827.js"><link rel="prefetch" href="/assets/js/60.c3d9ea70.js"><link rel="prefetch" href="/assets/js/61.d270b57a.js"><link rel="prefetch" href="/assets/js/62.b8500806.js"><link rel="prefetch" href="/assets/js/63.185fdf49.js"><link rel="prefetch" href="/assets/js/64.5715c3f8.js"><link rel="prefetch" href="/assets/js/65.34a0fce9.js"><link rel="prefetch" href="/assets/js/66.cf813c83.js"><link rel="prefetch" href="/assets/js/67.0dd6e7e8.js"><link rel="prefetch" href="/assets/js/68.a25443d8.js"><link rel="prefetch" href="/assets/js/69.93bd495a.js"><link rel="prefetch" href="/assets/js/7.aba13704.js"><link rel="prefetch" href="/assets/js/70.74f89d5a.js"><link rel="prefetch" href="/assets/js/71.0f32a425.js"><link rel="prefetch" href="/assets/js/72.e51b6946.js"><link rel="prefetch" href="/assets/js/73.1fbafed8.js"><link rel="prefetch" href="/assets/js/74.53bfe1e1.js"><link rel="prefetch" href="/assets/js/75.5cfd598a.js"><link rel="prefetch" href="/assets/js/76.064f8a35.js"><link rel="prefetch" href="/assets/js/77.453b4e5a.js"><link rel="prefetch" href="/assets/js/78.5cb78464.js"><link rel="prefetch" href="/assets/js/79.4bb3a291.js"><link rel="prefetch" href="/assets/js/8.03fd6845.js"><link rel="prefetch" href="/assets/js/80.0ce28102.js"><link rel="prefetch" href="/assets/js/81.f4c70e32.js"><link rel="prefetch" href="/assets/js/82.fb513557.js"><link rel="prefetch" href="/assets/js/83.35a5d6e9.js"><link rel="prefetch" href="/assets/js/84.0423bf8d.js"><link rel="prefetch" href="/assets/js/85.59329109.js"><link rel="prefetch" href="/assets/js/86.cbd77d93.js"><link rel="prefetch" href="/assets/js/87.924617e9.js"><link rel="prefetch" href="/assets/js/88.05bcfc5f.js"><link rel="prefetch" href="/assets/js/89.f257e0f7.js"><link rel="prefetch" href="/assets/js/9.a21caf3b.js"><link rel="prefetch" href="/assets/js/90.8cd408f1.js"><link rel="prefetch" href="/assets/js/91.0000c508.js"><link rel="prefetch" href="/assets/js/92.a952cc7c.js"><link rel="prefetch" href="/assets/js/93.69a109fa.js"><link rel="prefetch" href="/assets/js/94.6bf247d5.js"><link rel="prefetch" href="/assets/js/95.c52c5bfd.js"><link rel="prefetch" href="/assets/js/96.6c164c48.js"><link rel="prefetch" href="/assets/js/97.94bef0d8.js"><link rel="prefetch" href="/assets/js/98.73b4758b.js"><link rel="prefetch" href="/assets/js/99.e667d6a2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1cda4d67.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Young's blog" class="logo"> <span class="site-name can-hide">Young's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Spring/" class="nav-link">Spring</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章1</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/andanyang/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.png"> <div class="blogger-info"><h3>Young</h3> <span></span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Spring/" class="nav-link">Spring</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章1</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/andanyang/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/pages/Zookeeper-concept/" class="sidebar-link">Zookeeper入门相关概念总结</a></li><li><a href="/pages/Zookeeper-Combat/" class="sidebar-link">Zookeeper安装与使用实战</a></li><li><a href="/pages/Zookeeper-conf/" class="sidebar-link">Zookeeper配置文件详解</a></li><li><a href="/pages/Zookeeper-zab/" class="sidebar-link">Zookeeper一致性协议——ZAB</a></li><li><a href="/pages/Zookeeper-zkClient/" class="sidebar-link">Zookeeper实战之客户端Curator vs zkClient</a></li><li><a href="/pages/2bf80f/" aria-current="page" class="active sidebar-link">万字总结Zookeeper客户端Curator操作Api</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_1-2-curator-创建会话" class="sidebar-link">1.2. Curator 创建会话</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_1-3-crud-之-create-创建节点" class="sidebar-link">1.3. CRUD 之 Create 创建节点</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_1-4-crud-之-read-获取节点数据" class="sidebar-link">1.4. CRUD 之 Read 获取节点数据</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_1-5-crud-之-update-更新节点" class="sidebar-link">1.5. CRUD 之 update 更新节点</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_1-6-crud-之-delete-删除节点" class="sidebar-link">1.6. CRUD 之 delete 删除节点</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_1-7-异步接口" class="sidebar-link">1.7 异步接口</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_2-1-缓存" class="sidebar-link">2.1 缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2bf80f/#_2-1-1-path-cache" class="sidebar-link">2.1.1 Path Cache</a></li><li class="sidebar-sub-header level3"><a href="/pages/2bf80f/#_2-1-2-node-cache" class="sidebar-link">2.1.2 node Cache</a></li><li class="sidebar-sub-header level3"><a href="/pages/2bf80f/#_2-1-3-tree-cache" class="sidebar-link">2.1.3 Tree Cache</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_3-1leaderlatch" class="sidebar-link">3.1LeaderLatch</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_3-2-leaderselector" class="sidebar-link">3.2 LeaderSelector</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_4-1-可重入共享锁-shared-reentrant-lock" class="sidebar-link">4.1 可重入共享锁—Shared Reentrant Lock</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_4-2-不可重入共享锁-shared-lock" class="sidebar-link">4.2 不可重入共享锁—Shared Lock</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_4-3-可重入读写锁-shared-reentrant-read-write-lock" class="sidebar-link">4.3 可重入读写锁—Shared Reentrant Read Write Lock</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_4-4-信号量-shared-semaphore" class="sidebar-link">4.4 信号量—Shared Semaphore</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_4-5-多共享锁对象-multi-shared-lock" class="sidebar-link">4.5 多共享锁对象 —Multi Shared Lock</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_5-1-分布式-int-计数器-sharedcount" class="sidebar-link">5.1 分布式 int 计数器—SharedCount</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_5-2-分布式-long-计数器-distributedatomiclong" class="sidebar-link">5.2 分布式 long 计数器—DistributedAtomicLong</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_6-1-分布式队列-distributedqueue" class="sidebar-link">6.1 分布式队列—DistributedQueue</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_6-2-带-id-的分布式队列-distributedidqueue" class="sidebar-link">6.2 带 Id 的分布式队列—DistributedIdQueue</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_6-3-优先级分布式队列-distributedpriorityqueue" class="sidebar-link">6.3 优先级分布式队列—DistributedPriorityQueue</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_6-4-分布式延迟队列-distributeddelayqueue" class="sidebar-link">6.4 分布式延迟队列—DistributedDelayQueue</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_7-1-distributedbarrier" class="sidebar-link">7.1 DistributedBarrier</a></li><li class="sidebar-sub-header level2"><a href="/pages/2bf80f/#_7-2-双栅栏-distributeddoublebarrier" class="sidebar-link">7.2 双栅栏—DistributedDoubleBarrier</a></li></ul></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/categories/?category=Zookeeper" title="分类" data-v-06225672>Zookeeper</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/andanyoung" target="_blank" title="作者" class="beLink" data-v-06225672>andanyang</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-04-17</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">万字总结Zookeeper客户端Curator操作Api<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_1-curator-客户端的依赖包"><a href="#_1-curator-客户端的依赖包" class="header-anchor">#</a> 1. Curator 客户端的依赖包</h1> <p>curator 是 Netflix 公司开源的⼀套 Zookeeper 客户端框架，和 ZKClient ⼀样，Curator 解决了很多 Zookeeper 客户端⾮常底层的细节开发工作，包括连接重连，反复注册 Watcher 和 NodeExistsException 异常等，是最流行的 Zookeeper 客户端之⼀。从编码风格上来讲，它提供了基于 Fluent 的编程风格⽀持</p> <p>打开<a href="https://curator.apache.org/" target="_blank" rel="noopener noreferrer">Curator 的官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，我们可以看到，Curator 包含了以下几个包：</p> <ul><li><p>curator-framework：对 zookeeper 的底层 api 的一些封装；</p></li> <li><p>curator-client：提供一些客户端的操作，例如重试策略等；</p></li> <li><p>curator-recipes：封装了一些高级特性，如：Cache 事件监听、选举、分布式锁、分布式计数器、分布式 Barrier 等。</p></li></ul> <p>Maven 依赖 <a href="https://central.sonatype.com/artifact/org.apache.curator/curator-framework/" target="_blank" rel="noopener noreferrer">最新版查看<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>  		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.curator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>curator-framework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_1-2-curator-创建会话"><a href="#_1-2-curator-创建会话" class="header-anchor">#</a> 1.2. Curator 创建会话</h2> <p>使用 curator-framework 包中的工厂类 CuratorFrameworkFactory 中的静态方法 newClient，来创建客户端会话。</p> <p>1.使用 CuratorFramework 这个工⼚类的两个静态方法来创建⼀个客户端</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public static CuratorFramework newClient(String connectString, RetryPolicy retryPolicy)

public static CuratorFramework newClient(String connectString, int sessionTimeoutMs, int connectionTimeoutMs, RetryPolicy retryPolicy)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>其中参数 RetryPolicy 提供重试策略的接口，可以让用户实现⾃定义的重试策略，默认提供了以下实现， 分别为 ExponentialBackoffRetry（基于 backoff 的重连策略）、RetryNTimes（重连 N 次策略）、 RetryForever（永远重试策略）</p> <p>2.通过调用 CuratorFramework 中的 start()方法来启动会话</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3);
CuratorFramework client =
CuratorFrameworkFactory.newClient(&quot;127.0.0.1:2181&quot;,retryPolicy);
client.start();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3);
CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;127.0.0.1:2181&quot;,
 5000,1000,retryPolicy);
client.start();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>其实进⼀步查看源代码可以得知，其实这两种方法内部实现⼀样，只是对外包装成不同的方法。它们的 底层都是通过第三个方法 builder 来实现的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3);
private static CuratorFramework Client = CuratorFrameworkFactory.builder()
     .connectString(&quot;server1:2181,server2:2181,server3:2181&quot;)
     .sessionTimeoutMs(50000)
     .connectionTimeoutMs(30000)
     .retryPolicy(retryPolicy)
     .build();
client.start();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>参数：</p> <ul><li>connectString：zk 的 server 地址，多个 server 之间使用英文逗号分隔开</li> <li>connectionTimeoutMs：连接超时时间，如上是 30s，默认是 15s</li> <li>sessionTimeoutMs：会话超时时间，如上是 50s，默认是 60s</li> <li>retryPolicy：失败重试策略
<ul><li>ExponentialBackoffRetry：构造器含有三个参数 <code>ExponentialBackoffRetry(int baseSleepTimeMs, int maxRetries, int maxSleepMs)</code> <ul><li>baseSleepTimeMs：初始的 sleep 时间，用于计算之后的每次重试的 sleep 时间，
<ul><li>计算公式：当前 sleep 时间=baseSleepTimeMs*Math.max(1, random.nextInt(1&lt;&lt;(retryCount+1)))</li> <li>maxRetries：最⼤重试次数 maxSleepMs：最⼤ sleep 时间，如果上述的当前 sleep 计算出来⽐这个⼤，那么 sleep 用 这个时间，默认的最⼤时间是 Integer.MAX_VALUE 毫秒。</li></ul></li></ul></li> <li>其他，查看 org.apache.curator.RetryPolicy 接口的实现类</li></ul></li> <li>start()：完成会话的创建</li></ul> <p>代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZkClientFactory</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * @param connectionString    zk的连接地址
     * @param retryPolicy         重试策略
     * @param connectionTimeoutMs 连接
     * @param sessionTimeoutMs
     * @return CuratorFramework 实例
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">CuratorFramework</span> <span class="token function">createWithOptions</span><span class="token punctuation">(</span>
            <span class="token class-name">String</span> connectionString<span class="token punctuation">,</span>
            <span class="token class-name">RetryPolicy</span> retryPolicy<span class="token punctuation">,</span>
            <span class="token class-name">String</span> namespace<span class="token punctuation">,</span>
            <span class="token keyword">int</span> connectionTimeoutMs<span class="token punctuation">,</span>
            <span class="token keyword">int</span> sessionTimeoutMs<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">// builder 模式创建 CuratorFramework 实例</span>
        <span class="token keyword">return</span> <span class="token class-name">CuratorFrameworkFactory</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">connectString</span><span class="token punctuation">(</span>connectionString<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">retryPolicy</span><span class="token punctuation">(</span>retryPolicy<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">connectionTimeoutMs</span><span class="token punctuation">(</span>connectionTimeoutMs<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">sessionTimeoutMs</span><span class="token punctuation">(</span>sessionTimeoutMs<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">namespace</span><span class="token punctuation">(</span>namespace<span class="token punctuation">)</span>
                <span class="token comment">// 其他的创建选项</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>需要注意的是 namespace 含有隔离命名空间，即客户端对 Zookeeper 上数据节点的任何操作都是相对 namespace ⽬录进行的，这有利于实现不同的 Zookeeper 的业务之间的隔离</p> <h2 id="_1-3-crud-之-create-创建节点"><a href="#_1-3-crud-之-create-创建节点" class="header-anchor">#</a> 1.3. CRUD 之 Create 创建节点</h2> <p>使用 create()方法，最后使用 forPath 带上需要创建的节点路径。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>client<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">creatingParentContainersIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">withMode</span><span class="token punctuation">(</span><span class="token class-name">CreateMode</span><span class="token punctuation">.</span><span class="token constant">EPHEMERAL</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;init&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>Zookeeper 的节点创建模式：</strong></p> <p>使用 withMode（）方法，设置节点的类型。zookeeper 节点有四种类型：</p> <ul><li><p>（1）PERSISTENT 持久节点</p></li> <li><p>（2）PERSISTENT_SEQUENTIAL 持久顺序节点</p></li> <li><p>（3）PHEMERAL 临时节</p></li> <li><p>（4）EPHEMERAL_SEQUENTIAL 临时顺序节点</p></li></ul> <p>下面详细介绍一下四种节点的区别和联系。</p> <p>（1）持久节点（PERSISTENT）</p> <p>所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点。持久节点的生命周期是永久有效，不会因为创建该节点的客户端会话失效而消失。</p> <p>（2）持久顺序节点（PERSISTENT_SEQUENTIAL）</p> <p>这类节点的生命周期和持久节点是一致的。额外的特性是，在 ZK 中，每个父节点会为他的第一级子节点维护一份次序，会记录每个子节点创建的先后顺序。如果在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK 会自动为给定节点名加上一个表示次序的数字后缀，作为新的节点名。这个次序后缀的范围是整型的最大值。</p> <p>比如，在创建节点的时候只需要传入节点 “/test*”，这样之后，zookeeper 自动会给”test*”后面补充数字次序。</p> <p>（3）临时节点（EPHEMERAL）</p> <p>和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。这里还要注意一件事，就是当你客户端会话失效后，所产生的节点也不是一下子就消失了，也要过一段时间，大概是 10 秒以内，可以试一下，本机操作生成节点，在服务器端用命令来查看当前的节点数目，你会发现客户端已经 stop，但是产生的节点还在。</p> <p>另外，在临时节点下面不能创建子节点。</p> <p>（4）临时顺序节点（EPHEMERAL_SEQUENTIAL）</p> <p>此节点是属于临时节点，不过带有顺序，客户端会话结束节点就消失。</p> <p><strong>创建一个节点，初始内容为空</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意：如果没有设置节点属性，节点创建模式默认为持久化节点，内容默认为空</p> <p><strong>创建一个节点，附带初始化内容</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;init&quot;</span>.<span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>创建一个节点，指定创建模式（临时节点），内容为空</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">withMode</span><span class="token punctuation">(</span>CreateMode.EPHEMERAL<span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>创建一个节点，指定创建模式（临时节点），附带初始化内容</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">withMode</span><span class="token punctuation">(</span>CreateMode.EPHEMERAL<span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;init&quot;</span>.<span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>创建一个节点，指定创建模式（临时节点），附带初始化内容，并且自动递归创建父节点</strong></p> <p>这个 creatingParentContainersIfNeeded()接口非常有用，因为一般情况开发人员在创建一个子节点必须判断它的父节点是否存在，如果不存在直接创建会抛出 NoNodeException，使用 creatingParentContainersIfNeeded()之后 Curator 能够自动递归创建所有所需的父节点。</p> <h2 id="_1-4-crud-之-read-获取节点数据"><a href="#_1-4-crud-之-read-获取节点数据" class="header-anchor">#</a> 1.4. CRUD 之 Read 获取节点数据</h2> <p>与节点读取的有关的方法，主要有三个：</p> <p>（1）首先是判断节点是否存在，使用 checkExists 方法。</p> <p>（2）其次是获取节点的数据，使用 getData 方法。</p> <p>（3）最后是获取子节点列表，使用 getChildren 方法。</p> <p>演示代码如下：</p> <p><strong>读取一个节点的数据内容</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意，此方法返的返回值是 byte[ ];</p> <p><strong>读取一个节点的数据内容，同时获取到该节点的 stat</strong></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>Stat <span class="token function">stat</span> <span class="token operator">=</span> new Stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
client.getData<span class="token punctuation">(</span><span class="token punctuation">)</span>.storingStatIn<span class="token punctuation">(</span>stat<span class="token punctuation">)</span>.forPath<span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_1-5-crud-之-update-更新节点"><a href="#_1-5-crud-之-update-更新节点" class="header-anchor">#</a> 1.5. CRUD 之 update 更新节点</h2> <p><strong>更新一个节点的数据内容</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;data&quot;</span>.<span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意：该接口会返回一个 Stat 实例</p> <p><strong>更新一个节点的数据内容，强制指定版本进行更新</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">withVersion</span><span class="token punctuation">(</span>10086<span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;data&quot;</span>.<span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>检查节点是否存在</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">checkExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意：该方法返回一个 Stat 实例，用于检查 ZNode 是否存在的操作. 可以调用额外的方法(监控或者后台处理)并在最后调用 forPath( )指定要操作的 ZNode</p> <p><strong>获取某个节点的所有子节点路径</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">getChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意：该方法的返回值为 List<String>,获得 ZNode 的子节点 Path 列表。 可以调用额外的方法(监控、后台处理或者获取状态 watch, background or get stat) 并在最后调用 forPath()指定要操作的父 ZNode</String></p> <p>异步更新的代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>client.setData().inBackground(callback)
                .forPath(zkPath, payload);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_1-6-crud-之-delete-删除节点"><a href="#_1-6-crud-之-delete-删除节点" class="header-anchor">#</a> 1.6. CRUD 之 delete 删除节点</h2> <p><strong>删除一个节点</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>client<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意，此方法只能删除<strong>叶子节点</strong>，否则会抛出异常。</p> <p><strong>删除一个节点，并且递归删除其所有的子节点</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">deletingChildrenIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>删除一个节点，强制指定版本进行删除</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">withVersion</span><span class="token punctuation">(</span>10086<span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>删除一个节点，强制保证删除</strong></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">guaranteed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>guaranteed()接口是一个保障措施，只要客户端会话有效，那么 Curator 会在后台持续进行删除操作，直到删除节点成功。</p> <p>**注意：**上面的多个流式接口是可以自由组合的，例如：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>client.<span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">guaranteed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">deletingChildrenIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span>.<span class="token function">withVersion</span><span class="token punctuation">(</span>10086<span class="token punctuation">)</span>.<span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">&quot;path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_1-7-异步接口"><a href="#_1-7-异步接口" class="header-anchor">#</a> 1.7 异步接口</h2> <p>上面提到的创建、删除、更新、读取等方法都是同步的，Curator 提供异步接口，引入了<strong>BackgroundCallback</strong>接口用于处理异步接口调用之后服务端返回的结果信息。<strong>BackgroundCallback</strong>接口中一个重要的回调值为 CuratorEvent，里面包含事件类型、响应吗和节点的详细信息。</p> <p><strong>CuratorEventType</strong></p> <table><thead><tr><th style="text-align:center;">事件类型</th> <th style="text-align:center;">对应 CuratorFramework 实例的方法</th></tr></thead> <tbody><tr><td style="text-align:center;">CREATE</td> <td style="text-align:center;">#create()</td></tr> <tr><td style="text-align:center;">DELETE</td> <td style="text-align:center;">#delete()</td></tr> <tr><td style="text-align:center;">EXISTS</td> <td style="text-align:center;">#checkExists()</td></tr> <tr><td style="text-align:center;">GET_DATA</td> <td style="text-align:center;">#getData()</td></tr> <tr><td style="text-align:center;">SET_DATA</td> <td style="text-align:center;">#setData()</td></tr> <tr><td style="text-align:center;">CHILDREN</td> <td style="text-align:center;">#getChildren()</td></tr> <tr><td style="text-align:center;">SYNC</td> <td style="text-align:center;">#sync(String,Object)</td></tr> <tr><td style="text-align:center;">GET_ACL</td> <td style="text-align:center;">#getACL()</td></tr> <tr><td style="text-align:center;">SET_ACL</td> <td style="text-align:center;">#setACL()</td></tr> <tr><td style="text-align:center;">WATCHED</td> <td style="text-align:center;">#Watcher(Watcher)</td></tr> <tr><td style="text-align:center;">CLOSING</td> <td style="text-align:center;">#close()</td></tr></tbody></table> <p><strong>响应码(#getResultCode())</strong></p> <table><thead><tr><th style="text-align:center;">响应码</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">0</td> <td style="text-align:center;">OK，即调用成功</td></tr> <tr><td style="text-align:center;">-4</td> <td style="text-align:center;">ConnectionLoss，即客户端与服务端断开连接</td></tr> <tr><td style="text-align:center;">-110</td> <td style="text-align:center;">NodeExists，即节点已经存在</td></tr> <tr><td style="text-align:center;">-112</td> <td style="text-align:center;">SessionExpired，即会话过期</td></tr></tbody></table> <p>一个异步创建节点的例子如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Executor executor = Executors.newFixedThreadPool(2);
client.create()
     .creatingParentsIfNeeded()
     .withMode(CreateMode.EPHEMERAL)
     .inBackground((curatorFramework, curatorEvent) -&gt; {
     System.out.println(String.format(&quot;eventType:%s,resultCode:%s&quot;,curatorEvent.getType(),curatorEvent.getResultCode()));
     },executor)
     .forPath(&quot;path&quot;);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>注意：如果#inBackground()方法不指定 executor，那么会默认使用 Curator 的 EventThread 去进行异步处理。</p> <h1 id="_2-curator-食谱-高级特性"><a href="#_2-curator-食谱-高级特性" class="header-anchor">#</a> 2. Curator 食谱(高级特性)</h1> <p><strong>提醒：首先你必须添加 curator-recipes 依赖，下文仅仅对 recipes 一些特性的使用进行解释和举例，不打算进行源码级别的探讨</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  		&lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
            &lt;version&gt;5.4.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>重要提醒：强烈推荐使用 ConnectionStateListener 监控连接的状态，当连接状态为 LOST，curator-recipes 下的所有 Api 将会失效或者过期，尽管后面所有的例子都没有使用到 ConnectionStateListener。</p> <h2 id="_2-1-缓存"><a href="#_2-1-缓存" class="header-anchor">#</a> 2.1 缓存</h2> <p>Zookeeper 原生支持通过注册 Watcher 来进行事件监听，但是开发者需要反复注册(Watcher 只能单次注册单次使用)。Cache 是 Curator 中对事件监听的包装，<strong>可以看作是对事件监听的本地缓存视图</strong>，能够自动为开发者<strong>处理反复注册监听</strong>。Curator 提供了三种 Watcher(Cache)来监听结点的变化。</p> <h3 id="_2-1-1-path-cache"><a href="#_2-1-1-path-cache" class="header-anchor">#</a> 2.1.1 Path Cache</h3> <p>Path Cache 用来监控一个<strong>ZNode 的子节点</strong>. 当一个子节点增加， 更新，删除时， Path Cache 会改变它的状态， 会包含最新的子节点， 子节点的数据和状态，而状态的更变将通过 PathChildrenCacheListener 通知。</p> <p>实际使用时会涉及到四个类：</p> <ul><li>PathChildrenCache</li> <li>PathChildrenCacheEvent</li> <li>PathChildrenCacheListener</li> <li>ChildData</li></ul> <p>通过下面的构造函数创建 Path Cache:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">PathChildrenCache</span><span class="token punctuation">(</span><span class="token class-name">CuratorFramework</span> client<span class="token punctuation">,</span> <span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token keyword">boolean</span> cacheData<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>想使用 cache，必须调用它的<code>start</code>方法，使用完后调用<code>close</code>方法。 可以设置 StartMode 来实现启动的模式</p> <p>StartMode 有下面几种：</p> <ol><li>NORMAL：正常初始化。</li> <li>BUILD_INITIAL_CACHE：在调用 <code>start()</code> 之前会调用 <code>rebuild()</code>。</li> <li>POST_INITIALIZED_EVENT： 当 Cache 初始化数据后发送一个 PathChildrenCacheEvent.Type#INITIALIZED 事件</li></ol> <p><code>public void addListener(PathChildrenCacheListener listener)</code> 可以增加 listener 监听缓存的变化。</p> <p><code>getCurrentData()</code> 方法返回一个 <code>List</code> 对象，可以遍历所有的子节点。</p> <p><strong>设置/更新、移除其实是使用 client (CuratorFramework)来操作, 不通过 PathChildrenCache 操作：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>	@Test
    public void testPathCache() throws Exception {


        PathChildrenCache cache = new PathChildrenCache(client, PATH, true);
        cache.start();
        PathChildrenCacheListener cacheListener = (client1, event) -&gt; {
            System.out.println(&quot;事件类型：&quot; + event.getType());
            ChildData data = event.getData();
            if (null != data) {
                System.out.println(&quot;节点数据：&quot; + data.getPath() + &quot; = &quot; + new String(data.getData()));
            }
        };
        cache.getListenable().addListener(cacheListener);
        client.create().creatingParentsIfNeeded().forPath(PATH + &quot;/test01&quot;, &quot;01&quot;.getBytes());
        Thread.sleep(10);
        client.create().creatingParentsIfNeeded().forPath(PATH + &quot;/test02&quot;, &quot;02&quot;.getBytes());
        Thread.sleep(10);
        client.setData().forPath(PATH + &quot;/test01&quot;, &quot;01_V2&quot;.getBytes());
        Thread.sleep(10);
        for (ChildData data : cache.getCurrentData()) {
            System.out.println(&quot;getCurrentData:&quot; + data.getPath() + &quot; = &quot; + new String(data.getData()));
        }
        client.delete().forPath(PATH + &quot;/test01&quot;);
        Thread.sleep(10);
        client.delete().forPath(PATH + &quot;/test02&quot;);
        Thread.sleep(1000 * 5);
        cache.close();
        client.close();
        System.out.println(&quot;OK!&quot;);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>**注意：**如果 new PathChildrenCache(client, PATH, true)中的参数 cacheData 值设置为 false，则示例中的 event.getData().getData()、data.getData()将返回 null，cache 将不会缓存节点数据。</p> <p>**注意：**示例中的 Thread.sleep(10)可以注释掉，但是注释后事件监听的触发次数会不全，这可能与 PathCache 的实现原理有关，不能太过频繁的触发事件！</p> <h3 id="_2-1-2-node-cache"><a href="#_2-1-2-node-cache" class="header-anchor">#</a> 2.1.2 node Cache</h3> <p>Node Cache 与 Path Cache 类似，Node Cache 只是监听某一个特定的节点。它涉及到下面的三个类：</p> <ul><li><code>NodeCache</code> - Node Cache 实现类</li> <li><code>NodeCacheListener</code> - 节点监听器</li> <li><code>ChildData</code> - 节点数据</li></ul> <p>**注意：**使用 cache，依然要调用它的<code>start()</code>方法，使用完后调用<code>close()</code>方法。</p> <p>getCurrentData()将得到节点当前的状态，通过它的状态可以得到当前的值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>	@Test
    public void testNodeCache() throws Exception {

        client.create().creatingParentsIfNeeded().forPath(PATH);
        final NodeCache cache = new NodeCache(client, PATH);
        NodeCacheListener listener = () -&gt; {
            ChildData data = cache.getCurrentData();
            if (null != data) {
                System.out.println(&quot;节点数据：&quot; + new String(data.getData()));
            } else {
                System.out.println(&quot;节点被删除!&quot;);
            }
        };
        cache.getListenable().addListener(listener);
        cache.start();
        client.setData().forPath(PATH, &quot;01&quot;.getBytes());
        Thread.sleep(100);
        client.setData().forPath(PATH, &quot;02&quot;.getBytes());
        Thread.sleep(100);
        client.delete().deletingChildrenIfNeeded().forPath(PATH);
        Thread.sleep(1000 * 2);
        cache.close();
        client.close();
        System.out.println(&quot;OK!&quot;);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>**注意：**示例中的 Thread.sleep(10)可以注释，但是注释后事件监听的触发次数会不全，这可能与 NodeCache 的实现原理有关，不能太过频繁的触发事件！</p> <p>**注意：**NodeCache 只能监听一个节点的状态变化。</p> <h3 id="_2-1-3-tree-cache"><a href="#_2-1-3-tree-cache" class="header-anchor">#</a> 2.1.3 Tree Cache</h3> <p>Tree Cache 可以监控整个树上的所有节点(本节点和子节点)，类似于 PathCache 和 NodeCache 的组合，主要涉及到下面四个类：</p> <ul><li>TreeCache - Tree Cache 实现类</li> <li>TreeCacheListener - 监听器类</li> <li>TreeCacheEvent - 触发的事件类</li> <li>ChildData - 节点数据</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>	@Test
    public void testTreeCache() throws Exception {


        client.create().creatingParentsIfNeeded().forPath(PATH);

        TreeCache cache = new TreeCache(client, PATH);
        TreeCacheListener listener = (client1, event) -&gt; {
            byte[] bytes = client.getData().forPath(PATH);
            System.out.println(&quot;bytes = &quot; + bytes);
            System.out.println(&quot;事件类型：&quot; + event.getType() +
                    &quot; | 路径：&quot; + (null != event.getData() ? event.getData().getPath() : null));
        };
        cache.getListenable().addListener(listener);
        cache.start();
        client.setData().forPath(PATH, &quot;01&quot;.getBytes());
        Thread.sleep(100);
        client.setData().forPath(PATH, &quot;02&quot;.getBytes());
        Thread.sleep(100);

        client.create().forPath(PATH + &quot;/SubTree&quot;, &quot;SubTree&quot;.getBytes());
        client.setData().forPath(PATH + &quot;/SubTree&quot;, &quot;00PATHSubTree&quot;.getBytes());
        Thread.sleep(100);
        client.delete().deletingChildrenIfNeeded().forPath(PATH);
        Thread.sleep(1000 * 2);
        cache.close();
        client.close();
        System.out.println(&quot;OK!&quot;);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><blockquote><p>**注意：**TreeCache 在初始化(调用<code>start()</code>方法)的时候会回调<code>TreeCacheListener</code>实例一个事 TreeCacheEvent，而回调的 TreeCacheEvent 对象的 Type 为 INITIALIZED，ChildData 为 null，此时<code>event.getData().getPath()</code>很有可能导致空指针异常，这里应该主动处理并避免这种情况。</p></blockquote> <h1 id="_3-leader-选举"><a href="#_3-leader-选举" class="header-anchor">#</a> 3. Leader 选举</h1> <p>在分布式计算中， <strong>leader elections</strong>是很重要的一个功能， 这个选举过程是这样子的： 指派一个进程作为组织者，将任务分发给各节点。 在任务开始前， 哪个节点都不知道谁是 leader(领导者)或者 coordinator(协调者). 当选举算法开始执行后， 每个节点最终会得到一个唯一的节点作为任务 leader. 除此之外， 选举还经常会发生在 leader 意外宕机的情况下，新的 leader 要被选举出来。</p> <p>在 zookeeper 集群中，leader 负责写操作，然后通过 Zab 协议实现 follower 的同步，leader 或者 follower 都可以处理读操作。</p> <p>Curator 有两种 leader 选举的 recipe,分别是<strong>LeaderSelector</strong>和<strong>LeaderLatch</strong>。</p> <p>LeaderSelector 前者是所有存活的客户端不间断的轮流做 Leader，大同社会。</p> <p>LeaderLatch 后者是一旦选举出 Leader，除非有客户端挂掉重新触发选举，否则不会交出领导权。</p> <h2 id="_3-1leaderlatch"><a href="#_3-1leaderlatch" class="header-anchor">#</a> 3.1LeaderLatch</h2> <p>LeaderLatch 有两个构造函数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public LeaderLatch(CuratorFramework client, String latchPath)
public LeaderLatch(CuratorFramework client, String latchPath,  String id)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>LeaderLatch 的启动：</p> <p><code>leaderLatch.start( );</code></p> <p>一旦启动，LeaderLatch 会和其它使用相同<code>latchPath</code>的其它 LeaderLatch 交涉，然后其中一个最终会被选举为 leader，可以通过<code>hasLeadership</code>方法查看 LeaderLatch 实例是否 leader：</p> <p><code>leaderLatch.hasLeadership( );//返回true说明当前实例是leader</code></p> <p>类似 JDK 的 CountDownLatch， LeaderLatch 在请求成为 leadership 会 block(阻塞)，一旦不使用 LeaderLatch 了，必须调用<code>close</code>方法。 如果它是 leader,会释放 leadership， 其它的参与者将会选举一个 leader。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> public void await() throws InterruptedException,EOFException
/*Causes the current thread to wait until this instance acquires leadership
unless the thread is interrupted or closed.*/
public boolean await(long timeout,TimeUnit unit)throws InterruptedException
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>异常处理：</strong> LeaderLatch 实例可以增加 ConnectionStateListener 来监听网络连接问题。 当 SUSPENDED 或 LOST 时, leader 不再认为自己还是 leader。当 LOST 后连接重连后 RECONNECTED,LeaderLatch 会删除先前的 ZNode 然后重新创建一个。LeaderLatch 用户必须考虑导致 leadership 丢失的连接问题。 强烈推荐你使用 ConnectionStateListener。</p> <p>一个 LeaderLatch 的使用例子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> 	@Test
    public void testLeaderLatch() throws Exception {

        List&lt;CuratorFramework&gt; clients = Lists.newArrayList();

        List&lt;LeaderLatch&gt; examples = Lists.newArrayList();

        try {
            for (int i = 0; i &lt; CLIENT_QTY; i++) {

                CuratorFramework client = getClient();
                clients.add(client);
                LeaderLatch latch = new LeaderLatch(client, PATH, &quot;Client #&quot; + i);
                latch.addListener(new LeaderLatchListener() {

                    @Override
                    public void isLeader() {
                        // TODO Auto-generated method stub
                        System.out.println(&quot;I am Leader&quot;);
                    }

                    @Override
                    public void notLeader() {
                        // TODO Auto-generated method stub
                        System.out.println(&quot;I am not Leader&quot;);
                    }
                });
                examples.add(latch);
                client.start();
                latch.start();
            }
            Thread.sleep(1000);
            LeaderLatch currentLeader = null;
            do {
                for (LeaderLatch latch : examples) {
                    if (latch.hasLeadership()) {
                        currentLeader = latch;
                        System.out.println(&quot;current leader is &quot; + currentLeader.getId());
                    }
                }
            } while (currentLeader == null);


            System.out.println(&quot;release the leader &quot; + currentLeader.getId());
            currentLeader.close();
            //currentLeader.start();

            Thread.sleep(5000);

            for (LeaderLatch latch : examples) {
                if (latch.hasLeadership()) {
                    currentLeader = latch;
                }
            }
            System.out.println(&quot;current leader is &quot; + currentLeader.getId());
            System.out.println(&quot;release the leader &quot; + currentLeader.getId());
        } finally {
            for (LeaderLatch latch : examples) {
                if (null != latch.getState() &amp;&amp; latch.getState() != LeaderLatch.State.CLOSED)
                    CloseableUtils.closeQuietly(latch);
            }
            for (CuratorFramework client : clients) {
                CloseableUtils.closeQuietly(client);
            }
        }
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br></div></div><p>首先我们创建了 10 个 LeaderLatch，启动后它们中的一个会被选举为 leader。 因为选举会花费一些时间，start 后并不能马上就得到 leader。
通过<code>hasLeadership</code>查看自己是否是 leader， 如果是的话返回 true。
可以通过<code>.getLeader().getId()</code>可以得到当前的 leader 的 ID。
只能通过<code>close</code>释放当前的领导权。
<code>await</code>是一个阻塞方法， 尝试获取 leader 地位，但是未必能上位。</p> <h2 id="_3-2-leaderselector"><a href="#_3-2-leaderselector" class="header-anchor">#</a> 3.2 LeaderSelector</h2> <p>LeaderSelector 使用的时候主要涉及下面几个类：</p> <ul><li>LeaderSelector</li> <li>LeaderSelectorListener</li> <li>LeaderSelectorListenerAdapter</li> <li>CancelLeadershipException</li></ul> <p>核心类是 LeaderSelector，它的构造函数如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public LeaderSelector(CuratorFramework client, String mutexPath,LeaderSelectorListener listener)
public LeaderSelector(CuratorFramework client, String mutexPath, ThreadFactory threadFactory, Executor executor, LeaderSelectorListener listener)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>类似 LeaderLatch,LeaderSelector 必须<code>start</code>: <code>leaderSelector.start();</code> 一旦启动，当实例取得领导权时你的 listener 的<code>takeLeadership()</code>方法被调用。而 takeLeadership()方法只有领导权被释放时才返回。 当你不再使用 LeaderSelector 实例时，应该调用它的 close 方法。</p> <p><strong>异常处理</strong> LeaderSelectorListener 类继承 ConnectionStateListener。LeaderSelector 必须小心连接状态的改变。如果实例成为 leader, 它应该响应 SUSPENDED 或 LOST。 当 SUSPENDED 状态出现时， 实例必须假定在重新连接成功之前它可能不再是 leader 了。 如果 LOST 状态出现， 实例不再是 leader， takeLeadership 方法返回。</p> <p><strong>重要</strong>: 推荐处理方式是当收到 SUSPENDED 或 LOST 时抛出 CancelLeadershipException 异常.。这会导致 LeaderSelector 实例中断并取消执行 takeLeadership 方法的异常.。这非常重要， 你必须考虑扩展 LeaderSelectorListenerAdapter. LeaderSelectorListenerAdapter 提供了推荐的处理逻辑。</p> <p>下面的一个例子摘抄自官方：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> public class LeaderSelectorAdapter extends LeaderSelectorListenerAdapter implements Closeable {
    private final String name;
    private final LeaderSelector leaderSelector;
    private final AtomicInteger leaderCount = new AtomicInteger();

    public LeaderSelectorAdapter(CuratorFramework client, String path, String name) {
        this.name = name;
        leaderSelector = new LeaderSelector(client, path, this);
        leaderSelector.autoRequeue();
    }

    public void start() throws IOException {
        leaderSelector.start();
    }

    @Override
    public void close() throws IOException {
        leaderSelector.close();
    }

    @Override
    public void takeLeadership(CuratorFramework client) throws Exception {
        final int waitSeconds = (int) (5 * Math.random()) + 1;
        System.out.println(name + &quot; is now the leader. Waiting &quot; + waitSeconds + &quot; seconds...&quot;);
        System.out.println(name + &quot; has been leader &quot; + leaderCount.getAndIncrement() + &quot; time(s) before.&quot;);
        try {
            Thread.sleep(TimeUnit.SECONDS.toMillis(waitSeconds));
        } catch (InterruptedException e) {
            System.err.println(name + &quot; was interrupted.&quot;);
            Thread.currentThread().interrupt();
        } finally {
            System.out.println(name + &quot; relinquishing leadership.\n&quot;);
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><blockquote><p>你可以在 takeLeadership 进行任务的分配等等，并且不要返回，如果你想要要此实例一直是 leader 的话可以加一个死循环。调用 <code>leaderSelector.autoRequeue();</code>保证在此实例释放领导权之后还可能获得领导权。 在这里我们使用 AtomicInteger 来记录此 client 获得领导权的次数， 它是”fair”， 每个 client 有平等的机会获得领导权。</p></blockquote> <p>对比可知，LeaderLatch 必须调用<code>close()</code>方法才会释放领导权，而对于 LeaderSelector，通过<code>LeaderSelectorListener</code>可以对领导权进行控制， 在适当的时候释放领导权，这样每个节点都有可能获得领导权。从而，LeaderSelector 具有更好的灵活性和可控性，建议有 LeaderElection 应用场景下优先使用 LeaderSelector。</p> <h1 id="_4-分布式锁"><a href="#_4-分布式锁" class="header-anchor">#</a> 4.分布式锁</h1> <blockquote><p><strong>提醒：</strong></p> <p>1.推荐使用 ConnectionStateListener 监控连接的状态，因为当连接 LOST 时你不再拥有锁</p> <p>2.分布式的锁全局同步， 这意味着任何一个时间点不会有两个客户端都拥有相同的锁。</p></blockquote> <h2 id="_4-1-可重入共享锁-shared-reentrant-lock"><a href="#_4-1-可重入共享锁-shared-reentrant-lock" class="header-anchor">#</a> 4.1 可重入共享锁—Shared Reentrant Lock</h2> <p><strong>Shared 意味着锁是全局可见的</strong>， 客户端都可以请求锁。 Reentrant 和 JDK 的 ReentrantLock 类似，即可重入， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。 它是由类<code>InterProcessMutex</code>来实现。 它的构造函数为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public InterProcessMutex(CuratorFramework client, String path)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通过<code>acquire()</code>获得锁，并提供超时机制：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    /**
     * Acquire the mutex - blocking until it's available. Note: the same thread
     * can call acquire re-entrantly. Each call to acquire must be balanced by a call
     * to {@link #release()}
     *
     * @throws Exception ZK errors, connection interruptions
     */
    @Override
    public void acquire() throws Exception
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>通过<code>release()</code>方法释放锁。 InterProcessMutex 实例可以重用。<strong>Revoking</strong> ZooKeeper recipes wiki 定义了可协商的撤销机制。 为了撤销 mutex, 调用下面的方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    /**
     * Perform one release of the mutex if the calling thread is the same thread that acquired it. If the
     * thread had made multiple calls to acquire, the mutex will still be held when this method returns.
     *
     * @throws Exception ZK errors, interruptions, current thread does not own the lock
     */
    @Override
    public void release() throws Exception
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>Revoking</strong> ZooKeeper recipes wiki 定义了可协商的撤销机制。 为了撤销 mutex, 调用下面的方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>将锁设为可撤销的. 当别的进程或线程想让你释放锁时Listener会被调用。
public void makeRevocable(RevocationListener&lt;T&gt; listener)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果你请求撤销当前的锁， 调用<code>attemptRevoke()</code>方法,注意锁释放时<code>RevocationListener</code>将会回调。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public static void attemptRevoke(CuratorFramework client,String path) throws Exception
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>测试代码</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> private InterProcessMutex createLock() {
        return new InterProcessMutex(client, PATH);
    }


    @Test
    public void testShareLock() throws InterruptedException {

        CountDownLatch countDownLatch = new CountDownLatch(QTY);
        ExecutorService service = Executors.newFixedThreadPool(QTY);
        List&lt;InterProcessMutex&gt; locks = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; QTY; ++i) {
            int finalI = i;
            Runnable runnable = () -&gt; {
                InterProcessMutex lock = createLock();
                locks.add(lock);

                boolean acquire = false;
                try {
                    lock.acquire(10000, TimeUnit.SECONDS);
                    System.out.println(&quot;acquire Lock and run  &quot; + finalI + &quot; time:&quot; + System.currentTimeMillis());
                    Thread.sleep(10000);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                } finally {
                    try {
                        lock.release();
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }

                System.out.println(&quot;acquire Lock end : &quot; + finalI + &quot; time:&quot; + System.currentTimeMillis());
                countDownLatch.countDown();
            };


            service.execute(runnable);
            //service.execute(runnable);
        }

        countDownLatch.await();
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><h2 id="_4-2-不可重入共享锁-shared-lock"><a href="#_4-2-不可重入共享锁-shared-lock" class="header-anchor">#</a> 4.2 不可重入共享锁—Shared Lock</h2> <p>这个锁和上面的<code>InterProcessMutex</code>相比，就是少了 Reentrant 的功能，也就意味着它不能在同一个线程中重入。这个类是<code>InterProcessSemaphoreMutex</code>,使用方法和<code>InterProcessMutex</code>类似</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>private InterProcessSemaphoreMutex createInterProcessSemaphoreMutexLock() {
        return new InterProcessSemaphoreMutex(client, PATH);
    }

    @Test
    public void testInterProcessSemaphoreMutex() throws InterruptedException {


        CountDownLatch countDownLatch = new CountDownLatch(QTY);

        ExecutorService service = Executors.newFixedThreadPool(QTY);
        List&lt;InterProcessSemaphoreMutex&gt; locks = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; QTY; ++i) {
            int finalI = i;
            Runnable runnable = () -&gt; {
                InterProcessSemaphoreMutex lock = createInterProcessSemaphoreMutexLock();
                locks.add(lock);

                boolean acquire = false;
                try {
                    lock.acquire(10000, TimeUnit.SECONDS);
                    //lock.acquire(10000, TimeUnit.SECONDS);
                    System.out.println(&quot;acquire Lock and run  &quot; + finalI + &quot; time:&quot; + System.currentTimeMillis());
                    Thread.sleep(10000);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                } finally {
                    try {
                        lock.release();
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }

                System.out.println(&quot;acquire Lock end : &quot; + finalI + &quot; time:&quot; + System.currentTimeMillis());
                countDownLatch.countDown();
            };

			service.execute(runnable);
            service.execute(runnable);
        }

        countDownLatch.await();
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p>运行后发现，有且只有一个 client 成功获取第一个锁(第一个<code>acquire()</code>方法返回 true)，然后它自己阻塞在第二个<code>acquire()</code>方法，获取第二个锁超时；其他所有的客户端都阻塞在第一个<code>acquire()</code>方法超时并且抛出异常。</p> <p>这样也就验证了<code>InterProcessSemaphoreMutex</code>实现的锁是不可重入的。</p> <h2 id="_4-3-可重入读写锁-shared-reentrant-read-write-lock"><a href="#_4-3-可重入读写锁-shared-reentrant-read-write-lock" class="header-anchor">#</a> 4.3 可重入读写锁—Shared Reentrant Read Write Lock</h2> <p>类似 JDK 的<strong>ReentrantReadWriteLock</strong>。一个读写锁管理一对相关的锁。一个负责读操作，另外一个负责写操作。读操作在写锁没被使用时可同时由多个进程使用，而写锁在使用时不允许读(阻塞)。</p> <p>此锁是可重入的。<strong>一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁</strong>。这也意味着<strong>写锁可以降级成读锁， 比如请求写锁 ---&gt;请求读锁---&gt;释放读锁 ----&gt;释放写锁</strong>。从读锁升级成写锁是不行的。</p> <p>可重入读写锁主要由两个类实现：<code>InterProcessReadWriteLock</code>、<code>InterProcessMutex</code>。使用时首先创建一个<code>InterProcessReadWriteLock</code>实例，然后再根据你的需求得到读锁或者写锁，读写锁的类型是<code>InterProcessMutex</code>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Test
    public void testReadWriteLock() throws InterruptedException {

        CountDownLatch countDownLatch = new CountDownLatch(QTY);

        ExecutorService service = Executors.newFixedThreadPool(QTY);
        List&lt;InterProcessReadWriteLock&gt; locks = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; QTY; ++i) {
            int finalI = i;
            Runnable runnable = () -&gt; {
                InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, PATH);
                InterProcessReadWriteLock.ReadLock readLock = lock.readLock();
                InterProcessReadWriteLock.WriteLock writeLock = lock.writeLock();
                locks.add(lock);

                boolean acquire = false;
                try {
                    if (readLock.acquire(-1, TimeUnit.SECONDS)) {
                        System.out.println(&quot;acquire readLock and run  &quot; + finalI + &quot; time:&quot; + System.currentTimeMillis());
                        readLock.release();
                        Thread.sleep(1000);
                        System.out.println(&quot;acquire readLock end  &quot; + finalI + &quot; time:&quot; + System.currentTimeMillis());
                    }
                    if (finalI / 2 == 0 &amp;&amp; writeLock.acquire(-1, TimeUnit.SECONDS)) {
                        System.out.println(&quot;acquire writeLock and run  &quot; + finalI + &quot; time:&quot; + System.currentTimeMillis());
                        Thread.sleep(1000);
                        System.out.println(&quot;acquire writeLock end  &quot; + finalI + &quot; time:&quot; + System.currentTimeMillis());
                    }
                    System.out.println(&quot;acquire Lock and run  &quot; + finalI + &quot; time:&quot; + System.currentTimeMillis());
                    Thread.sleep(10000);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }

                System.out.println(&quot;acquire Lock end : &quot; + finalI + &quot; time:&quot; + System.currentTimeMillis());
                countDownLatch.countDown();
            };


            service.execute(runnable);
            //service.execute(runnable);
        }

        countDownLatch.await();
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><h2 id="_4-4-信号量-shared-semaphore"><a href="#_4-4-信号量-shared-semaphore" class="header-anchor">#</a> 4.4 信号量—Shared Semaphore</h2> <p>一个计数的信号量类似 JDK 的 Semaphore。 JDK 中 Semaphore 维护的一组许可(<strong>permits</strong>)，而 Curator 中称之为租约(<strong>Lease</strong>)。 有两种方式可以决定 semaphore 的最大租约数。第一种方式是用户给定 path 并且指定最大 LeaseSize。第二种方式用户给定 path 并且使用<code>SharedCountReader</code>类。<strong>如果不使用 SharedCountReader, 必须保证所有实例在多进程中使用相同的(最大)租约数量,否则有可能出现 A 进程中的实例持有最大租约数量为 10，但是在 B 进程中持有的最大租约数量为 20，此时租约的意义就失效了。</strong></p> <p>这次调用<code>acquire()</code>会返回一个租约对象。 客户端必须在 finally 中 close 这些租约对象，否则这些租约会丢失掉。 但是， 但是，如果客户端 session 由于某种原因比如 crash 丢掉， 那么这些客户端持有的租约会自动 close， 这样其它客户端可以继续使用这些租约。 租约还可以通过下面的方式返还：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public void returnAll(Collection&lt;Lease&gt; leases)
public void returnLease(Lease lease)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>注意你可以一次性请求多个租约，如果 Semaphore 当前的租约不够，则请求线程会被阻塞。 同时还提供了超时的重载方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public Lease acquire()
public Collection&lt;Lease&gt; acquire(int qty)
public Lease acquire(long time, TimeUnit unit)
public Collection&lt;Lease&gt; acquire(int qty, long time, TimeUnit unit)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Shared Semaphore 使用的主要类包括下面几个：</p> <ul><li><code>InterProcessSemaphoreV2</code></li> <li><code>Lease</code></li> <li><code>SharedCountReader</code></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Test
    public void testInterProcessSemaphore() throws Exception {
        InterProcessSemaphoreV2 interProcessSemaphoreV2 = new InterProcessSemaphoreV2(client, PATH, QTY);

        ExecutorService service = Executors.newFixedThreadPool(QTY);
        CountDownLatch countDownLatch = new CountDownLatch(2);


        Runnable runnable1 = () -&gt; {
            Collection&lt;Lease&gt; acquire = null;
            try {
                acquire = interProcessSemaphoreV2.acquire(2, 1000000, TimeUnit.SECONDS);
                System.out.println(&quot;acquire = runnable1&quot; + acquire);
                Thread.sleep(10000);

                interProcessSemaphoreV2.returnAll(acquire);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            countDownLatch.countDown();
        };

        Runnable runnable2 = () -&gt; {
            Collection&lt;Lease&gt; acquire = null;
            try {
                acquire = interProcessSemaphoreV2.acquire(1, 1000000, TimeUnit.SECONDS);
                System.out.println(&quot;acquire = runnable2&quot; + acquire);
                Thread.sleep(10000);
                interProcessSemaphoreV2.returnAll(acquire);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

            countDownLatch.countDown();
        };

        Runnable runnable3 = () -&gt; {
            Collection&lt;Lease&gt; acquire = null;
            try {
                acquire = interProcessSemaphoreV2.acquire(QTY, 1000000, TimeUnit.SECONDS);
                System.out.println(&quot;acquire = runnable3&quot; + acquire);
                Thread.sleep(10000);
                interProcessSemaphoreV2.returnAll(acquire);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            countDownLatch.countDown();
        };


        service.execute(runnable1);
        Thread.sleep(1000);
        service.execute(runnable2);
        Thread.sleep(1000);
        service.execute(runnable3);

        countDownLatch.await();
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br></div></div><p>首先我们先获得了 2 个租约， 10s 后我们把它还给了 semaphore。 接着请求了一个租约，因为 semaphore 还有 3 个租约，所以请求可以满足，返回一个租约，还剩 2 个租约。 然后再请求 5 个租约，因为租约不够，<strong>阻塞到超时，还是没能满足，返回结果为 null(租约不足会阻塞到超时，然后返回 null，不会主动抛出异常；如果不设置超时时间，会一致阻塞)。</strong></p> <p>上面说讲的锁都是公平锁(fair)。 总 ZooKeeper 的角度看， 每个客户端都按照请求的顺序获得锁，不存在非公平的抢占的情况。</p> <h2 id="_4-5-多共享锁对象-multi-shared-lock"><a href="#_4-5-多共享锁对象-multi-shared-lock" class="header-anchor">#</a> 4.5 多共享锁对象 —Multi Shared Lock</h2> <p>Multi Shared Lock 是一个锁的容器。 当调用<code>acquire()</code>， 所有的锁都会被<code>acquire()</code>，如果请求失败，所有的锁都会被 release。 同样调用 release 时所有的锁都被 release(<strong>失败被忽略</strong>)。 基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。</p> <p>主要涉及两个类：</p> <ul><li><code>InterProcessMultiLock</code></li> <li><code>InterProcessLock</code></li></ul> <p>它的构造函数需要包含的锁的集合，或者一组 ZooKeeper 的 path。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public InterProcessMultiLock(List&lt;InterProcessLock&gt; locks)
public InterProcessMultiLock(CuratorFramework client, List&lt;String&gt; paths)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>public class MultiSharedLockDemo {

    private static final String PATH1 = &quot;/examples/locks1&quot;;
    private static final String PATH2 = &quot;/examples/locks2&quot;;

    private static final String PATH = &quot;/curator-test&quot;;
    static CuratorFramework client;

    public static void main(String[] args) throws Exception {


        before();

        InterProcessLock lock1 = new InterProcessMutex(client, PATH1);
        InterProcessLock lock2 = new InterProcessSemaphoreMutex(client, PATH2);

        InterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(lock1, lock2));

        if (!lock.acquire(10, TimeUnit.SECONDS)) {
            throw new IllegalStateException(&quot;could not acquire the lock&quot;);
        }
        System.out.println(&quot;has got all lock&quot;);

        System.out.println(&quot;has got lock1: &quot; + lock1.isAcquiredInThisProcess());
        System.out.println(&quot;has got lock2: &quot; + lock2.isAcquiredInThisProcess());

        try {
            //access resource exclusively
            System.out.println(&quot;lock = &quot; + lock);
            Thread.sleep(1000);
        } finally {
            System.out.println(&quot;releasing the lock&quot;);
            lock.release(); // always release the lock in a finally block
        }
        System.out.println(&quot;has got lock1: &quot; + lock1.isAcquiredInThisProcess());
        System.out.println(&quot;has got lock2: &quot; + lock2.isAcquiredInThisProcess());
    }

    public static void before() {

        ExponentialBackoffRetry retryPolicy =
                new ExponentialBackoffRetry(100, 3);
        client = ZkClientFactory.createWithOptions(
                &quot;192.168.1.13:2181&quot;, retryPolicy, null, 3000, 20000);

        client.start();
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br></div></div><p>新建一个<code>InterProcessMultiLock</code>， 包含一个重入锁和一个非重入锁。 调用<code>acquire()</code>后可以看到线程同时拥有了这两个锁。 调用<code>release()</code>看到这两个锁都被释放了。</p> <h1 id="_5-分布式计数器"><a href="#_5-分布式计数器" class="header-anchor">#</a> 5.分布式计数器</h1> <p>顾名思义，计数器是用来计数的, 利用 ZooKeeper 可以实现一个集群共享的计数器。 只要使用相同的 path 就可以得到最新的计数器值， 这是由 ZooKeeper 的一致性保证的。Curator 有两个计数器， 一个是用 int 来计数(<code>SharedCount</code>)，一个用 long 来计数(<code>DistributedAtomicLong</code>)。</p> <h2 id="_5-1-分布式-int-计数器-sharedcount"><a href="#_5-1-分布式-int-计数器-sharedcount" class="header-anchor">#</a> 5.1 分布式 int 计数器—SharedCount</h2> <p>这个类使用 int 类型来计数。 主要涉及三个类。</p> <ul><li>SharedCount</li> <li>SharedCountReader</li> <li>SharedCountListener</li></ul> <p><code>SharedCount</code>代表计数器， 可以为它增加一个<code>SharedCountListener</code>，当计数器改变时此 Listener 可以监听到改变的事件，而<code>SharedCountReader</code>可以读取到最新的值， 包括字面值和带版本信息的值 VersionedValue。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> public class SharedCounterDemo implements SharedCountListener {

    private static final int QTY = 5;
    private static final String PATH = &quot;/examples/counter&quot;;

    public static void main(String[] args) throws IOException, Exception {
        final Random rand = new Random();
        SharedCounterDemo example = new SharedCounterDemo();
        try (TestingServer server = new TestingServer()) {
            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));
            client.start();

            SharedCount baseCount = new SharedCount(client, PATH, 0);
            baseCount.addListener(example);
            baseCount.start();

            List&lt;SharedCount&gt; examples = Lists.newArrayList();
            ExecutorService service = Executors.newFixedThreadPool(QTY);
            for (int i = 0; i &lt; QTY; ++i) {
                final SharedCount count = new SharedCount(client, PATH, 0);
                examples.add(count);
                Callable&lt;Void&gt; task = () -&gt; {
                    count.start();
                    Thread.sleep(rand.nextInt(10000));
                    System.out.println(&quot;Increment:&quot; + count.trySetCount(count.getVersionedValue(), count.getCount() + rand.nextInt(10)));
                    return null;
                };
                service.submit(task);
            }

            service.shutdown();
            service.awaitTermination(10, TimeUnit.MINUTES);

            for (int i = 0; i &lt; QTY; ++i) {
                examples.get(i).close();
            }
            baseCount.close();
        }
        Thread.sleep(Integer.MAX_VALUE);
    }

    @Override
    public void stateChanged(CuratorFramework arg0, ConnectionState arg1) {
        System.out.println(&quot;State changed: &quot; + arg1.toString());
    }

    @Override
    public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {
        System.out.println(&quot;Counter's value is changed to &quot; + newCount);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><p>在这个例子中，我们使用<code>baseCount</code>来监听计数值(<code>addListener</code>方法来添加 SharedCountListener )。 任意的 SharedCount， 只要使用相同的 path，都可以得到这个计数值。 然后我们使用 5 个线程为计数值增加一个 10 以内的随机数。相同的 path 的 SharedCount 对计数值进行更改，将会回调给<code>baseCount</code>的 SharedCountListener。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>count.trySetCount(count.getVersionedValue(), count.getCount() + rand.nextInt(10))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里我们使用<code>trySetCount</code>去设置计数器。 <strong>第一个参数提供当前的 VersionedValue,如果期间其它 client 更新了此计数值， 你的更新可能不成功， 但是这时你的 client 更新了最新的值，所以失败了你可以尝试再更新一次。 而<code>setCount</code>是强制更新计数器的值</strong>。</p> <blockquote><p>注意计数器必须<code>start</code>,使用完之后必须调用<code>close</code>关闭它。</p></blockquote> <h2 id="_5-2-分布式-long-计数器-distributedatomiclong"><a href="#_5-2-分布式-long-计数器-distributedatomiclong" class="header-anchor">#</a> 5.2 分布式 long 计数器—DistributedAtomicLong</h2> <p>再看一个 Long 类型的计数器。 除了计数的范围比<code>SharedCount</code>大了之外， 它首先尝试使用乐观锁的方式设置计数器， 如果不成功(比如期间计数器已经被其它 client 更新了)， 它使用<code>InterProcessMutex</code>方式来更新计数值。</p> <p>可以从它的内部实现<code>DistributedAtomicValue.trySet()</code>中看出：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>   AtomicValue&lt;byte[]&gt;   trySet(MakeValue makeValue) throws Exception
    {
        MutableAtomicValue&lt;byte[]&gt;  result = new MutableAtomicValue&lt;byte[]&gt;(null, null, false);

        tryOptimistic(result, makeValue);
        if ( !result.succeeded() &amp;&amp; (mutex != null) )
        {
            tryWithMutex(result, makeValue);
        }

        return result;
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>计数器有一系列的操作：</p> <ul><li>get(): 获取当前值</li> <li>increment()： 加一</li> <li>decrement(): 减一</li> <li>add()： 增加特定的值</li> <li>subtract(): 减去特定的值</li> <li>trySet(): 尝试设置计数值</li> <li>forceSet(): 强制设置计数值</li></ul> <p>你<strong>必须</strong>检查返回结果的<code>succeeded()</code>， 它代表此操作是否成功。 如果操作成功， <code>preValue()</code>代表操作前的值， <code>postValue()</code>代表操作后的值。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DistributedAtomicLongDemo</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">QTY</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">PATH</span> <span class="token operator">=</span> <span class="token string">&quot;/examples/counter&quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DistributedAtomicLong</span><span class="token punctuation">&gt;</span></span> examples <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">TestingServer</span> server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestingServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">CuratorFramework</span> client <span class="token operator">=</span> <span class="token class-name">CuratorFrameworkFactory</span><span class="token punctuation">.</span><span class="token function">newClient</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span><span class="token function">getConnectString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ExponentialBackoffRetry</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            client<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token constant">QTY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">QTY</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">final</span> <span class="token class-name">DistributedAtomicLong</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DistributedAtomicLong</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> <span class="token constant">PATH</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RetryNTimes</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                examples<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token class-name">AtomicValue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> value <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;succeed: &quot;</span> <span class="token operator">+</span> value<span class="token punctuation">.</span><span class="token function">succeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">succeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Increment: from &quot;</span> <span class="token operator">+</span> value<span class="token punctuation">.</span><span class="token function">preValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; to &quot;</span> <span class="token operator">+</span> value<span class="token punctuation">.</span><span class="token function">postValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">;</span>
                service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            service<span class="token punctuation">.</span><span class="token function">awaitTermination</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h1 id="_6-分布式队列"><a href="#_6-分布式队列" class="header-anchor">#</a> 6. 分布式队列</h1> <p>使用 Curator 也可以简化 Ephemeral Node (<strong>临时节点</strong>)的操作。Curator 也提供 ZK Recipe 的分布式队列实现。 利用 ZK 的 PERSISTENTS_EQUENTIAL 节点， 可以保证放入到队列中的项目是按照顺序排队的。 如果单一的消费者从队列中取数据， 那么它是先入先出的，这也是队列的特点。 如果你严格要求顺序，你就的使用单一的消费者，可以使用 Leader 选举只让 Leader 作为唯一的消费者。</p> <p>但是， 根据 Netflix 的 Curator 作者所说， ZooKeeper 真心不适合做 Queue，或者说 ZK 没有实现一个好的 Queue，详细内容可以看 <a href="https://link.jianshu.com/?t=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FCURATOR%2FTN4" target="_blank" rel="noopener noreferrer">Tech Note 4<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>， 原因有五：</p> <ol><li>ZK 有 1MB 的传输限制。 实践中 ZNode 必须相对较小，而队列包含成千上万的消息，非常的大。</li> <li>如果有很多节点，ZK 启动时相当的慢。 而使用 queue 会导致好多 ZNode. 你需要显著增大 initLimit 和 syncLimit.</li> <li>ZNode 很大的时候很难清理。Netflix 不得不创建了一个专门的程序做这事。</li> <li>当很大量的包含成千上万的子节点的 ZNode 时， ZK 的性能变得不好</li> <li>ZK 的数据库完全放在内存中。 大量的 Queue 意味着会占用很多的内存空间。</li></ol> <p>尽管如此， Curator 还是创建了各种 Queue 的实现。 如果 Queue 的数据量不太多，数据量不太大的情况下，酌情考虑，还是可以使用的。</p> <h2 id="_6-1-分布式队列-distributedqueue"><a href="#_6-1-分布式队列-distributedqueue" class="header-anchor">#</a> 6.1 分布式队列—DistributedQueue</h2> <p>DistributedQueue 是最普通的一种队列。 它设计以下四个类：</p> <ul><li>QueueBuilder - 创建队列使用 QueueBuilder,它也是其它队列的创建类</li> <li>QueueConsumer - 队列中的消息消费者接口</li> <li>QueueSerializer - 队列消息序列化和反序列化接口，提供了对队列中的对象的序列化和反序列化</li> <li>DistributedQueue - 队列实现类</li></ul> <p>QueueConsumer 是消费者，它可以接收队列的数据。处理队列中的数据的代码逻辑可以放在 QueueConsumer.consumeMessage()中。</p> <p>正常情况下先将消息从队列中移除，再交给消费者消费。但这是两个步骤，不是原子的。可以调用 Builder 的 lockPath()消费者加锁，当消费者消费数据时持有锁，这样其它消费者不能消费此消息。如果消费失败或者进程死掉，消息可以交给其它进程。这会带来一点性能的损失。最好还是单消费者模式使用队列。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> public class DistributedQueueDemo {

    private static final String PATH = &quot;/example/queue&quot;;

    public static void main(String[] args) throws Exception {
        TestingServer server = new TestingServer();
        CuratorFramework clientA = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));
        clientA.start();
        CuratorFramework clientB = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));
        clientB.start();
        DistributedQueue&lt;String&gt; queueA;
        QueueBuilder&lt;String&gt; builderA = QueueBuilder.builder(clientA, createQueueConsumer(&quot;A&quot;), createQueueSerializer(), PATH);
        queueA = builderA.buildQueue();
        queueA.start();

        DistributedQueue&lt;String&gt; queueB;
        QueueBuilder&lt;String&gt; builderB = QueueBuilder.builder(clientB, createQueueConsumer(&quot;B&quot;), createQueueSerializer(), PATH);
        queueB = builderB.buildQueue();
        queueB.start();
        for (int i = 0; i &lt; 100; i++) {
            queueA.put(&quot; test-A-&quot; + i);
            Thread.sleep(10);
            queueB.put(&quot; test-B-&quot; + i);
        }
        Thread.sleep(1000 * 10);// 等待消息消费完成
        queueB.close();
        queueA.close();
        clientB.close();
        clientA.close();
        System.out.println(&quot;OK!&quot;);
    }

    /**
     * 队列消息序列化实现类
     */
    private static QueueSerializer&lt;String&gt; createQueueSerializer() {
        return new QueueSerializer&lt;String&gt;() {
            @Override
            public byte[] serialize(String item) {
                return item.getBytes();
            }

            @Override
            public String deserialize(byte[] bytes) {
                return new String(bytes);
            }
        };
    }

    /**
     * 定义队列消费者
     */
    private static QueueConsumer&lt;String&gt; createQueueConsumer(final String name) {
        return new QueueConsumer&lt;String&gt;() {
            @Override
            public void stateChanged(CuratorFramework client, ConnectionState newState) {
                System.out.println(&quot;连接状态改变: &quot; + newState.name());
            }

            @Override
            public void consumeMessage(String message) throws Exception {
                System.out.println(&quot;消费消息(&quot; + name + &quot;): &quot; + message);
            }
        };
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br></div></div><p>例子中定义了两个分布式队列和两个消费者，因为 PATH 是相同的，会存在消费者抢占消费消息的情况。</p> <h2 id="_6-2-带-id-的分布式队列-distributedidqueue"><a href="#_6-2-带-id-的分布式队列-distributedidqueue" class="header-anchor">#</a> 6.2 带 Id 的分布式队列—DistributedIdQueue</h2> <p>DistributedIdQueue 和上面的队列类似，<strong>但是可以为队列中的每一个元素设置一个 ID</strong>。 可以通过 ID 把队列中任意的元素移除。 它涉及几个类：</p> <ul><li>QueueBuilder</li> <li>QueueConsumer</li> <li>QueueSerializer</li> <li>DistributedQueue</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>//创建
builder.buildIdQueue()
//放入元素
queue.put(aMessage, messageId);
//移除元素时
int numberRemoved = queue.remove(messageId);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_6-3-优先级分布式队列-distributedpriorityqueue"><a href="#_6-3-优先级分布式队列-distributedpriorityqueue" class="header-anchor">#</a> 6.3 优先级分布式队列—DistributedPriorityQueue</h2> <p>优先级队列对队列中的元素按照优先级进行排序。 <strong>Priority 越小， 元素越靠前， 越先被消费掉</strong>。</p> <p>通过 builder.buildPriorityQueue(minItemsBeforeRefresh)方法创建。 当优先级队列得到元素增删消息时，它会暂停处理当前的元素队列，然后刷新队列。minItemsBeforeRefresh 指定刷新前当前活动的队列的最小数量。 主要设置你的程序可以容忍的不排序的最小值。</p> <p>放入队列时需要指定优先级：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>queue.put(aMessage, priority);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>列子</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> public class DistributedPriorityQueueDemo {

    private static final String PATH = &quot;/example/queue&quot;;

    public static void main(String[] args) throws Exception {
        TestingServer server = new TestingServer();
        CuratorFramework client = null;
        DistributedPriorityQueue&lt;String&gt; queue = null;
        try {
            client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));
            client.getCuratorListenable().addListener((client1, event) -&gt; System.out.println(&quot;CuratorEvent: &quot; + event.getType().name()));

            client.start();
            QueueConsumer&lt;String&gt; consumer = createQueueConsumer();
            QueueBuilder&lt;String&gt; builder = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH);
            queue = builder.buildPriorityQueue(0);
            queue.start();

            for (int i = 0; i &lt; 10; i++) {
                int priority = (int) (Math.random() * 100);
                System.out.println(&quot;test-&quot; + i + &quot; priority:&quot; + priority);
                queue.put(&quot;test-&quot; + i, priority);
                Thread.sleep((long) (50 * Math.random()));
            }

            Thread.sleep(20000);

        } catch (Exception ex) {

        } finally {
            CloseableUtils.closeQuietly(queue);
            CloseableUtils.closeQuietly(client);
            CloseableUtils.closeQuietly(server);
        }
    }

    private static QueueSerializer&lt;String&gt; createQueueSerializer() {
        return new QueueSerializer&lt;String&gt;() {

            @Override
            public byte[] serialize(String item) {
                return item.getBytes();
            }

            @Override
            public String deserialize(byte[] bytes) {
                return new String(bytes);
            }

        };
    }

    private static QueueConsumer&lt;String&gt; createQueueConsumer() {

        return new QueueConsumer&lt;String&gt;() {

            @Override
            public void stateChanged(CuratorFramework client, ConnectionState newState) {
                System.out.println(&quot;connection new state: &quot; + newState.name());
            }

            @Override
            public void consumeMessage(String message) throws Exception {
                Thread.sleep(1000);
                System.out.println(&quot;consume one message: &quot; + message);
            }

        };
    }

}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br></div></div><p>有时候你可能会有错觉，优先级设置并没有起效。那是因为优先级是对于队列积压的元素而言，如果消费速度过快有可能出现在后一个元素入队操作之前前一个元素已经被消费，这种情况下 DistributedPriorityQueue 会退化为 DistributedQueue。</p> <h2 id="_6-4-分布式延迟队列-distributeddelayqueue"><a href="#_6-4-分布式延迟队列-distributeddelayqueue" class="header-anchor">#</a> 6.4 分布式延迟队列—DistributedDelayQueue</h2> <p>JDK 中也有 DelayQueue，不知道你是否熟悉。 DistributedDelayQueue 也提供了类似的功能， 元素有个 delay 值， 消费者隔一段时间才能收到元素。</p> <p>通过下面的语句创建：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>QueueBuilder&lt;MessageType&gt;    builder = QueueBuilder.builder(client, consumer, serializer, path);
... more builder method calls as needed ...
DistributedDelayQueue&lt;MessageType&gt; queue = builder.buildDelayQueue();
//放入元素时可以指定delayUntilEpoch：

queue.put(aMessage, delayUntilEpoch);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>注意<code>delayUntilEpoch</code>不是离现在的一个时间间隔， 比如 20 毫秒，而是未来的一个时间戳，如 System.currentTimeMillis() + 10 秒。 如果 delayUntilEpoch 的时间已经过去，消息会立刻被消费者接收。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> public class DistributedDelayQueueDemo {

    private static final String PATH = &quot;/example/queue&quot;;

    public static void main(String[] args) throws Exception {
        TestingServer server = new TestingServer();
        CuratorFramework client = null;
        DistributedDelayQueue&lt;String&gt; queue = null;
        try {
            client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));
            client.getCuratorListenable().addListener((client1, event) -&gt; System.out.println(&quot;CuratorEvent: &quot; + event.getType().name()));

            client.start();
            QueueConsumer&lt;String&gt; consumer = createQueueConsumer();
            QueueBuilder&lt;String&gt; builder = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH);
            queue = builder.buildDelayQueue();
            queue.start();

            for (int i = 0; i &lt; 10; i++) {
                queue.put(&quot;test-&quot; + i, System.currentTimeMillis() + 10000);
            }
            System.out.println(new Date().getTime() + &quot;: already put all items&quot;);


            Thread.sleep(20000);

        } catch (Exception ex) {

        } finally {
            CloseableUtils.closeQuietly(queue);
            CloseableUtils.closeQuietly(client);
            CloseableUtils.closeQuietly(server);
        }
    }

    private static QueueSerializer&lt;String&gt; createQueueSerializer() {
        return new QueueSerializer&lt;String&gt;() {

            @Override
            public byte[] serialize(String item) {
                return item.getBytes();
            }

            @Override
            public String deserialize(byte[] bytes) {
                return new String(bytes);
            }

        };
    }

    private static QueueConsumer&lt;String&gt; createQueueConsumer() {

        return new QueueConsumer&lt;String&gt;() {

            @Override
            public void stateChanged(CuratorFramework client, ConnectionState newState) {
                System.out.println(&quot;connection new state: &quot; + newState.name());
            }

            @Override
            public void consumeMessage(String message) throws Exception {
                System.out.println(new Date().getTime() + &quot;: consume one message: &quot; + message);
            }

        };
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br></div></div><h1 id="_7-分布式屏障-barrier"><a href="#_7-分布式屏障-barrier" class="header-anchor">#</a> 7. 分布式屏障—Barrier</h1> <p>分布式 Barrier 是这样一个类： 它会阻塞所有节点上的等待进程，直到某一个被满足， 然后所有的节点继续进行。</p> <p>比如赛马比赛中， 等赛马陆续来到起跑线前。 一声令下，所有的赛马都飞奔而出。</p> <h2 id="_7-1-distributedbarrier"><a href="#_7-1-distributedbarrier" class="header-anchor">#</a> 7.1 DistributedBarrier</h2> <p><code>DistributedBarrier</code>类实现了栅栏的功能。 它的构造函数如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public DistributedBarrier(CuratorFramework client, String barrierPath)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>首先你需要设置栅栏，它将阻塞在它上面等待的线程:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>setBarrier();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>然后需要阻塞的线程调用方法等待放行条件:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public void waitOnBarrier()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当条件满足时，移除栅栏，所有等待的线程将继续执行：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>removeBarrier();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>异常处理</strong> DistributedBarrier 会监控连接状态，当连接断掉时<code>waitOnBarrier()</code>方法会抛出异常。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> public class DistributedBarrierDemo {

    private static final int QTY = 5;
    private static final String PATH = &quot;/examples/barrier&quot;;

    public static void main(String[] args) throws Exception {
        try (TestingServer server = new TestingServer()) {
            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));
            client.start();
            ExecutorService service = Executors.newFixedThreadPool(QTY);
            DistributedBarrier controlBarrier = new DistributedBarrier(client, PATH);
            controlBarrier.setBarrier();

            for (int i = 0; i &lt; QTY; ++i) {
                final DistributedBarrier barrier = new DistributedBarrier(client, PATH);
                final int index = i;
                Callable&lt;Void&gt; task = () -&gt; {
                    Thread.sleep((long) (3 * Math.random()));
                    System.out.println(&quot;Client #&quot; + index + &quot; waits on Barrier&quot;);
                    barrier.waitOnBarrier();
                    System.out.println(&quot;Client #&quot; + index + &quot; begins&quot;);
                    return null;
                };
                service.submit(task);
            }
            Thread.sleep(10000);
            System.out.println(&quot;all Barrier instances should wait the condition&quot;);
            controlBarrier.removeBarrier();
            service.shutdown();
            service.awaitTermination(10, TimeUnit.MINUTES);

            Thread.sleep(20000);
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>这个例子创建了<code>controlBarrier</code>来设置栅栏和移除栅栏。 我们创建了 5 个线程，在此 Barrier 上等待。 最后移除栅栏后所有的线程才继续执行。</p> <h2 id="_7-2-双栅栏-distributeddoublebarrier"><a href="#_7-2-双栅栏-distributeddoublebarrier" class="header-anchor">#</a> 7.2 双栅栏—DistributedDoubleBarrier</h2> <p>双栅栏允许客户端在计算的开始和结束时同步。当足够的进程加入到双栅栏时，进程开始计算， 当计算完成时，离开栅栏。 双栅栏类是<code>DistributedDoubleBarrier</code>。 构造函数为:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public DistributedDoubleBarrier(CuratorFramework client,
                                String barrierPath,
                                int memberQty)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>memberQty</code>是成员数量，当<code>enter()</code>方法被调用时，成员被阻塞，直到所有的成员都调用了<code>enter()</code>。 当<code>leave()</code>方法被调用时，它也阻塞调用线程，直到所有的成员都调用了<code>leave()</code>。 就像百米赛跑比赛， 发令枪响， 所有的运动员开始跑，等所有的运动员跑过终点线，比赛才结束。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
public class DistributedDoubleBarrierDemo {

    private static final int QTY = 5;
    private static final String PATH = &quot;/examples/barrier&quot;;

    public static void main(String[] args) throws Exception {
        try (TestingServer server = new TestingServer()) {
            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));
            client.start();
            ExecutorService service = Executors.newFixedThreadPool(QTY);
            for (int i = 0; i &lt; QTY; ++i) {
                final DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, PATH, QTY);
                final int index = i;
                Callable&lt;Void&gt; task = () -&gt; {

                    Thread.sleep((long) (3 * Math.random()));
                    System.out.println(&quot;Client #&quot; + index + &quot; enters&quot;);
                    barrier.enter();
                    System.out.println(&quot;Client #&quot; + index + &quot; begins&quot;);
                    Thread.sleep((long) (3000 * Math.random()));
                    barrier.leave();
                    System.out.println(&quot;Client #&quot; + index + &quot; left&quot;);
                    return null;
                };
                service.submit(task);
            }

            service.shutdown();
            service.awaitTermination(10, TimeUnit.MINUTES);
            Thread.sleep(Integer.MAX_VALUE);
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><h1 id="代码"><a href="#代码" class="header-anchor">#</a> 代码</h1> <p><a href="https://github.com/andanyoung/springboot/tree/master/zookeeper" target="_blank" rel="noopener noreferrer">https://github.com/andanyoung/springboot/tree/master/zookeeper<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/andanyang/vuepress-theme-vdoing/edit/master/docs/Zookeeper/0011.万字总结Zookeeper客户端Curator操作Api.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/08/17, 02:54:24</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/Zookeeper-zkClient/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Zookeeper实战之客户端Curator vs zkClient</div></a> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/Zookeeper-zkClient/" class="prev">Zookeeper实战之客户端Curator vs zkClient</a></span> <!----></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/Spring_boot/Multithreaded_transaction_rollback_processing/"><div>
            多线程事务回滚的处理
            <!----></div></a> <span class="date">08-10</span></dt></dl><dl><dd>02</dd> <dt><a href="/Spring_boot/Spring_Transaction/"><div>
            Spring事务详解
            <!----></div></a> <span class="date">08-10</span></dt></dl><dl><dd>03</dd> <dt><a href="/IT/KPI_IT/"><div>
            如何对技术人员进行绩效考核
            <!----></div></a> <span class="date">08-10</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1218853253@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/andanyang" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2023
    <span>Young | <a href="https://github.com/andanyoung/young-blog/blob/master/LICENSE" target="_blank">MIT License</a> <br/> <a  href="https://beian.miit.gov.cn/" target="_blank">浙ICP备20002744号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.450efd07.js" defer></script><script src="/assets/js/2.7973be65.js" defer></script><script src="/assets/js/112.eb871c6e.js" defer></script>
  </body>
</html>
