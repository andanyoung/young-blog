<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第2章 Spring基础 | Young&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="Young丶java后端技术博客,专注后端学习与总结。擅长spring boot,JAVA基础总结,等方面的知识,关注spring,架构,elasticsearch,mysql领域.">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.d9c8cf8c.css" as="style"><link rel="preload" href="/assets/js/app.57cec729.js" as="script"><link rel="preload" href="/assets/js/2.fabf76d0.js" as="script"><link rel="preload" href="/assets/js/11.f4e96788.js" as="script"><link rel="prefetch" href="/assets/js/10.f32fd760.js"><link rel="prefetch" href="/assets/js/12.920bbfb4.js"><link rel="prefetch" href="/assets/js/13.6f152d47.js"><link rel="prefetch" href="/assets/js/14.1bc6ecda.js"><link rel="prefetch" href="/assets/js/15.251c6e98.js"><link rel="prefetch" href="/assets/js/16.b8ce402d.js"><link rel="prefetch" href="/assets/js/17.8facb8b0.js"><link rel="prefetch" href="/assets/js/18.27084040.js"><link rel="prefetch" href="/assets/js/19.e7146235.js"><link rel="prefetch" href="/assets/js/20.a9733603.js"><link rel="prefetch" href="/assets/js/21.dbb39be3.js"><link rel="prefetch" href="/assets/js/22.a00031a5.js"><link rel="prefetch" href="/assets/js/3.9050f421.js"><link rel="prefetch" href="/assets/js/4.94dce7a4.js"><link rel="prefetch" href="/assets/js/5.a9b7859a.js"><link rel="prefetch" href="/assets/js/6.f6262793.js"><link rel="prefetch" href="/assets/js/7.3ee79e18.js"><link rel="prefetch" href="/assets/js/8.1085e0a6.js"><link rel="prefetch" href="/assets/js/9.ef1ba1fc.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d9c8cf8c.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Young's blog" class="logo"> <span class="site-name can-hide">Young's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Spring/" class="nav-link">Spring</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章1</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/andanyang/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.png"> <div class="blogger-info"><h3>Young</h3> <span></span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Spring/" class="nav-link">Spring</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章1</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/andanyang/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/spring/java/" class="sidebar-link">第 1 章 Java 基础</a></li><li><a href="/pages/base/" aria-current="page" class="active sidebar-link">第2章 Spring基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/base/#_2-1-spring-框架介绍" class="sidebar-link">2.1 Spring 框架介绍</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/base/#_2-1-1-起源" class="sidebar-link">2.1.1 起源</a></li><li class="sidebar-sub-header level3"><a href="/pages/base/#_2-1-2-简介" class="sidebar-link">2.1.2 简介</a></li><li class="sidebar-sub-header level3"><a href="/pages/base/#_2-1-3-框架结构" class="sidebar-link">2.1.3 框架结构</a></li><li class="sidebar-sub-header level4"><a href="/pages/base/#_1-核心容器" class="sidebar-link">1．核心容器</a></li><li class="sidebar-sub-header level4"><a href="/pages/base/#_2-aop" class="sidebar-link">2．AOP</a></li><li class="sidebar-sub-header level4"><a href="/pages/base/#_3-消息发送" class="sidebar-link">3．消息发送</a></li><li class="sidebar-sub-header level4"><a href="/pages/base/#_4-数据访问-集成" class="sidebar-link">4．数据访问／集成</a></li><li class="sidebar-sub-header level4"><a href="/pages/base/#_6-测试" class="sidebar-link">6．测试</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/base/#_2-2-spring-ioc" class="sidebar-link">2.2 Spring IoC</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/base/#_2-2-1-什么是-spring-ioc" class="sidebar-link">2.2.1 什么是 Spring IoC</a></li><li class="sidebar-sub-header level3"><a href="/pages/base/#_2-2-2-ioc-实例" class="sidebar-link">2.2.2 IOC 实例</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/base/#_2-3-spring-aop" class="sidebar-link">2.3 Spring AoP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/base/#_2-3-1-什么是-aop" class="sidebar-link">2.3.1 什么是 AOP</a></li><li class="sidebar-sub-header level3"><a href="/pages/base/#_2-3-2-spring-aop-和-aspectj-aop-有什么区别" class="sidebar-link">2.3.2 Spring AOP 和 AspectJ AOP 有什么区别？</a></li><li class="sidebar-sub-header level3"><a href="/pages/base/#_2-2-3-aspectj-定义的通知类型有哪些" class="sidebar-link">2.2.3 AspectJ 定义的通知类型有哪些？</a></li><li class="sidebar-sub-header level3"><a href="/pages/base/#_2-3-4-多个切面的执行顺序如何控制" class="sidebar-link">2.3.4 多个切面的执行顺序如何控制？</a></li><li class="sidebar-sub-header level3"><a href="/pages/base/#_2-3-5-aop-原理" class="sidebar-link">2.3.5 AOP 原理</a></li><li class="sidebar-sub-header level4"><a href="/pages/base/#_1-在每处调用的地方增加日志和-try-catch" class="sidebar-link">1．在每处调用的地方增加日志和 try catch</a></li><li class="sidebar-sub-header level4"><a href="/pages/base/#_2-代理模式" class="sidebar-link">2．代理模式</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/base/#_2-4-小结" class="sidebar-link">2.4 小结</a></li><li class="sidebar-sub-header level2"><a href="/pages/base/#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/pages/ioc/" class="sidebar-link">第3章 Spring IOC 核心容器</a></li><li><a href="/pages/e7599c/" class="sidebar-link">第4章 Spring之AOP</a></li><li><a href="/pages/299451/" class="sidebar-link">第5章 Spring之DAO</a></li><li><a href="/pages/923052/" class="sidebar-link">第 6 章 Spring的IoC容器系列</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>进阶</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/categories/?category=Spring" title="分类" data-v-06225672>Spring</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/andanyang" target="_blank" title="作者" class="beLink" data-v-06225672>andanyang</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-02-24</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">第2章 Spring基础<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="第-2-章-spring-基础"><a href="#第-2-章-spring-基础" class="header-anchor">#</a> 第 2 章 Spring 基础</h1> <p>在上一章节中，我们学习了 Java 的注解与反射，在这一章节我们将了解一下 Spring 框架，并学习 Spring 框架中重要的编程思想控制反转（IOC）、面向切面编程（AOP）。语言只是工具，最重要的是编程思想。掌握了编程思想，不仅是 Java，其他编程语言也就容易学习了。
本章主要涉及的知识点：</p> <ul><li>Spring 概述：了解 Spring 框架的起源、简介、结构。</li> <li>依赖注入：什么是依赖注入？依赖注入的好处是什么？</li> <li>控制反转：什么是控制反转？依赖注入与控制反转的联系是什么？</li> <li>面向切面编程：什么是面向切面编程？面向切面编程的原理。</li> <li>实例应用：通过本章 IOC、AOP 示例，演示 Spring 中 IOC、AOP 的简单应用，通过动手实践加深对 IOC、AOP 的理解。</li></ul> <h2 id="_2-1-spring-框架介绍"><a href="#_2-1-spring-框架介绍" class="header-anchor">#</a> 2.1 Spring 框架介绍</h2> <p>本节主要对 Spring 框架进行简单介绍，了解框架起源、框架组成结构，对 Spring 框架有一个大概的认识。官网地址：<a href="https://spring.io/" target="_blank" rel="noopener noreferrer">https://spring.io/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_2-1-1-起源"><a href="#_2-1-1-起源" class="header-anchor">#</a> 2.1.1 起源</h3> <p>首先，追根溯源，了解它是怎么来的。在 Spring 框架出现之前，使用 EJB 开发 J2EE 应用可没那么容易。EJB 要严格地实现各种不同类型的接口，代码复用性低，配置也比较复杂和单调，同样使用 JNDI 进行对象查找的代码也是单调而枯燥，而且 EJB 不容易学，开发效率低。Spring 出现的初衷就是为了解决类似的这些问题。</p> <p>Spring 最大的目的之一就是使 J2EE 开发更加容易。同时，Spring 不仅仅是一个单层的框架，而是类似一个平台或者生态体系。在这个平台或者生态体系中，可以将 Struts、Hibernate 等单层框架最佳的方式融合在一起，为企业级应用提供完美的解决方案。Spring 的形成，最初来自 Rod Jahnson 所著的一本很有影响力的图书《Expert One-on-One J2EE Design and Development》（出版于 2002 年），就是在这本书中第一次出现了 Spring 的一些核心思想。另外，《Expert One-on-One J2EE Development without EJB》更进一步地阐述了在不使用 EJB 开发 J2EE 企业级应用的一些设计思想和具体的做法。</p> <h3 id="_2-1-2-简介"><a href="#_2-1-2-简介" class="header-anchor">#</a> 2.1.2 简介</h3> <p>了解了 Spring 框架的起源之后，下面来了解一下 Spring 到底是什么。用一句话概括，Spring 就是一个开源的轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。下面来分析一下这句话。</p> <ul><li>（1）开源：因为开源、免费，用户无须经过任何人同意即可修改代码，可控制性强，不受他人限制。</li> <li>（2）轻量级：从大小与开销两方面而言，Spring 都是轻量的。完整的 Spring 框架可以在一个大小只有 1MB 多的 JAR 文件里发布，并且 Spring 所需的处理开销也是微不足道的。此外，Spring 是非侵入式的，Spring 应用中的对象不依赖于 Spring 的特定类。</li> <li>（3）控制反转：软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准，划分模块的一个准则就是高内聚低耦合，Spring 通过控制反转技术降低了耦合度。</li> <li>（4）面向切片：Spring 支持面向切片的编程，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发，应用对象只需实现业务逻辑，它们并不负责（甚至是意识）其他系统级关注点，例如日志或事务支持。</li> <li>（5）容器：容器就是用来装东西的。Spring 容器包含并管理应用对象的配置和生命周期。</li> <li>（6）框架：Spring 可以将简单的组件配置、组合成为复杂的应用，相当于是一个脚手架，开发者要做的就是把组件放进去，实现业务逻辑。</li></ul> <h3 id="_2-1-3-框架结构"><a href="#_2-1-3-框架结构" class="header-anchor">#</a> 2.1.3 框架结构</h3> <div class="language- extra-class"><pre><code>Spring框架结构如图2-1所示。
</code></pre></div><p><img src="https://img-blog.csdnimg.cn/img_convert/031f68512967ecb0cfaef249291f7569.png" alt="图2-1"></p> <p>Spring 由 20 多个模块组成，可以分为核心容器（Core Container）、数据访问／集成（Data Access/Integration）、Web、面向切面编程（AOP，Aspect Oriented Programming）、设备（Instrumentation）、消息发送（Messaging）和测试（Test）。</p> <h4 id="_1-核心容器"><a href="#_1-核心容器" class="header-anchor">#</a> 1．核心容器</h4> <p>核心容器包含 spring-core、spring-beans、spring-context、spring-context-support 和 spring-expression（Spring Expression Language）这些模块。
spring-core 和 spring-beans 构成了框架最基础的部分，包括控制反转和依赖注入功能。
<a href="https://andyoung.blog.csdn.net/article/details/109731834" target="_blank" rel="noopener noreferrer">spring-context<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是基于 spring-core 和 spring-beans 构建的，提供了一种以框架风格来访问对象的方式，类似于 JNDI 注册。ApplicationContext 接口是 spring-context 的焦点。
spring-context-support 为集成第三方库（如定时器 Quartz）提供支持。
spring-expression 提供了一种强大的表达式语言，可以在运行时查询和操作对象。</p> <h4 id="_2-aop"><a href="#_2-aop" class="header-anchor">#</a> 2．AOP</h4> <p>spring-aop 模块提供了一个 AOP 面向切面编程的实现。
spring-aspects 模块提供与 AspectJ 的集成。
spring-instrument 模块提供一些类级的工具支持和 ClassLoader 级的实现，用于服务器。spring-instrument-tomcat 模块针对 tomcat 的 instrument 实现。</p> <h4 id="_3-消息发送"><a href="#_3-消息发送" class="header-anchor">#</a> 3．消息发送</h4> <p>从 Spring 4 开始包含了一个 spring-messaging 模块，对 Spring 集成项目 Message、MessageChannel 和 MessageHandler 进行了重要的抽象，是基于消息发送应用的基础。</p> <h4 id="_4-数据访问-集成"><a href="#_4-数据访问-集成" class="header-anchor">#</a> 4．数据访问／集成</h4> <p>数据访问／集成层包含 JDBC（spring-jdbc）、ORM（spring-orm）、OXM（spring-oxm）、JMS（spring-jms）和事务（spring-tx）模块。
5．Web
Web 层包含 spring-web、spring-webmvc、spring-websocket 和 spring-webflux 模块。其中，spring-web 提供了面向 Web 集成的基本特性，比如文件上传功能。Spring-webmvc 模块包含了 Spring 的 MVC 和 REST Web Service 实现。spring-webflux 是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的、非阻塞、事件驱动的服务，并且扩展性非常好。</p> <h4 id="_6-测试"><a href="#_6-测试" class="header-anchor">#</a> 6．测试</h4> <p>Spring-test 模块支持 Spring 组建 JUnit 和 TestNG 的单元测试和集成测试。</p> <h2 id="_2-2-spring-ioc"><a href="#_2-2-spring-ioc" class="header-anchor">#</a> 2.2 Spring IoC</h2> <h3 id="_2-2-1-什么是-spring-ioc"><a href="#_2-2-1-什么是-spring-ioc" class="header-anchor">#</a> 2.2.1 什么是 Spring IoC</h3> <p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p> <p><strong>为什么叫控制反转？</strong></p> <ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li> <li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul> <p><img src="https://img-blog.csdnimg.cn/img_convert/f14e44e7418dc41af9867df1a053e293.png" alt="为什么叫控制反转？"></p> <p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p> <p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p> <p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p> <p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p> <h3 id="_2-2-2-ioc-实例"><a href="#_2-2-2-ioc-实例" class="header-anchor">#</a> 2.2.2 IOC 实例</h3> <blockquote><p>光说不练假把式，特别是 IT 技术，经常会出现看能看懂但写不出来的尴尬局面。上面分析了一下依赖注入与控制反转，本节将通过示例来加深理解。这里还是使用人与空气的例子。
人依赖空气，在传统的方式创建两个类：一个是 Person 类，一个是 CleanAir 类。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>class CleanAir{

    public  String toString(){
        return &quot;CleanAir&quot;;
    }
}

class Person{

    CleanAir air;
    public Person(CleanAir air){
        this.air = air;
    }
    public  String toString(){
        return &quot;Person&quot;;
    }

    public void breath(){
        System.out.println(air.toString());
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>上面两个类实现了依赖的关系，还有就是注入。在了解注入之前，我们还有一个问题要思考。有这样一句话：世界上唯一不变的就是变化。之前干净的空气不复存在，而 Person 依赖的不再是 CleanAir，而是比 CleanAir 更有内涵的 DirtyAir。如果还是按照上面的方式来，那就需要在增加一个 DirtyAir 类的同时修改 Person。这种强依赖有很大的弊端，一个地方变化引起其他地方变化，而且改变的只是 Air，但 Person 也要改变。怎么样才能尽量减少修改的地方呢？于是面向接口的编程出现了。下面先定义一个接口 IAir，类 CleanAir 实现接口 IAir，在 Person 中不再直接依赖 CleanAir，而是依赖接口 IAir，这样即使是 DirtyAir 也只需要给 Person 修改不同的 Air 就行了。这个注入的过程，利用 Spring 框架只需要改一下配置即可实现。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface IAir {}

class CleanAir implements IAir{

    public  String toString(){
        return &quot;CleanAir&quot;;
    }
}

class DirtyAir implements IAir{

    public  String toString(){
        return &quot;DirtyAir&quot;;
    }
}

class Person{

    IAir air;
    public Person(IAir air){
        this.air = air;
    }
    public  String toString(){
        return &quot;Person&quot;;
    }

    public void breath(){
        System.out.println(air.toString());
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>上面定义 IAir 接口算是对依赖关系的优化，降低了人与空气的耦合度，但是并没有使用 New 关键字创建对象，只是定义了依赖关系。下面用 Spring 实现注入。</p> <ul><li>（1）创建一个 Maven Project，archetype 选择 quickstart，如图 2-2 所示。</li></ul> <p><img src="https://img-blog.csdnimg.cn/img_convert/5a40214387ddc1092286e131997b7249.png" alt="图2-2"></p> <p>图 2-2</p> <ul><li>（2）创建之后，既然要使用 Spring 框架来实现注入，那肯定要在项目中引入 Spring 框架，配置 pom.xml，添加依赖。
① 在 properties 节点配置要引入 Spring 的版本号，这里用的是 5.0.0.RELEASE。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>  &lt;properties&gt;
    &lt;spring．version&gt;5.0.0.RELEASE&lt;/spring.version&gt;
  &lt;/properties&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>② 引入。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
      &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ul><li><p>（3）实现依赖注入。</p> <p>前面创建的 IAir 接口、Person 类、CleanAir 类、DirtyAir 类实现了依赖关系，但是怎么让 Spring 框架识别到呢？不可能把各个类创建好就结束了，还需要进行配置才能让 Spring 知道哪些是组件。这里对 Person 类、CleanAir 类、DirtyAir 类在上面定义的基础上进行修改。</p></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>public interface IAir {
}

@Component
public class CleanAir implements IAir {
    public  String toString(){
        return &quot;CleanAir&quot;;
    }
}

@Component
public class DirtyAir implements IAir {
    public  String toString(){
        return &quot;DirtyAir&quot;;
    }
}


@Component
public class Person {

    IAir air;
    @Autowired //对构造函数进行标注
    public Person(@Qualifier(&quot;dirtyair&quot;) IAir air){
        this.air = air;
    }
    public  String toString(){
        return &quot;Person&quot;;
    }

    public void breath(){
        System.out.println(air.toString());
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>在上面的代码中使用了@Component 将类注解成组件，使用@Autowired 将 IAir 类型对象注入 Person 中。CleanAir 类、DirtyAir 类都实现了 IAir 接口，怎么让 Person 具体注入哪个对象呢？使用@Qualifier 关键字来进行区分，这里使用的是 qualifier=dirtyair。同时这些组件定义之后还要告诉 Spring 框架组件位置在哪，所以在 scr/main/resources 下新建了 ApplicationContext.xml 进行配置。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;spring.tutorial.chapter2.*&quot; /&gt;
    &lt;bean id=&quot;CleanAir&quot; class=&quot;spring.tutorial.chapter2.air.impl.CleanAir&quot;&gt;
        &lt;qualifier value=&quot;cleanair&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;DirtyAir&quot; class=&quot;spring.tutorial.chapter2.air.impl.DirtyAir&quot;&gt;
        &lt;qualifier value=&quot;dirtyair&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;person&quot; class=&quot;spring.tutorial.chapter2.Person&quot; /&gt;
&lt;/beans&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li>（4）测试。
在 main 中获取到应用上下文，通过 getBean 方法获取 Person 对象，然后调用 Breath()方法。不了解 ClassPathXmlApplicationContext、getBean 这些方法也没关系，在后面的章节会有详细介绍。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>public class Chapter1
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext(new  String[] {
            &quot;ApplicationContext.xml&quot;
        });
        BeanFactory factory = context;
        Person person = (Person) factory.getBean(&quot;person&quot;);
        person.breath();
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>输出结果：</p></blockquote> <p><code>DirtyAir</code></p> <p>如果想使用 CleanAir 对象，只需要把 Person 类中@Qualifier 注解 value 的值改为 CleanAir 对应的 beanId：cleanair。</p> <ul><li>（5）小结
参考上面的示例思考 2.2.1 和 2.2.2 节中的概念，就会发现依赖注入、控制反转其实也不难。理解了依赖注入、控制反转对后面 Spring 框架的学习会有更大的帮助。</li></ul> <h2 id="_2-3-spring-aop"><a href="#_2-3-spring-aop" class="header-anchor">#</a> 2.3 Spring AoP</h2> <p>本节主要认识横切、纵切，理解什么是 AOP（Aspect-Oriented Programming，面向切面编程）以及 AOP 的实现原理。在此基础上通过示例动手操作加深理解。</p> <h3 id="_2-3-1-什么是-aop"><a href="#_2-3-1-什么是-aop" class="header-anchor">#</a> 2.3.1 什么是 AOP</h3> <p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p> <p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于<strong>没有实现接口的对象</strong>，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/230ae587a322d6e4d09510161987d346.jpeg" alt=""></p> <p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p> <p>AOP 切面编程设计到的一些专业术语：</p> <table><thead><tr><th style="text-align:left;">术语</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:left;">目标(Target)</td> <td style="text-align:center;">被通知的对象</td></tr> <tr><td style="text-align:left;">代理(Proxy)</td> <td style="text-align:center;">向目标对象应用通知之后创建的代理对象</td></tr> <tr><td style="text-align:left;">连接点(JoinPoint)</td> <td style="text-align:center;">目标对象的所属类中，定义的所有方法均为连接点</td></tr> <tr><td style="text-align:left;">切入点(Pointcut)</td> <td style="text-align:center;">被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td></tr> <tr><td style="text-align:left;">通知(Advice)</td> <td style="text-align:center;">增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情</td></tr> <tr><td style="text-align:left;">切面(Aspect)</td> <td style="text-align:center;">切入点(Pointcut)+通知(Advice)</td></tr> <tr><td style="text-align:left;">Weaving(织入)</td> <td style="text-align:center;">将通知应用到目标对象，进而生成代理对象的过程动作</td></tr></tbody></table> <h3 id="_2-3-2-spring-aop-和-aspectj-aop-有什么区别"><a href="#_2-3-2-spring-aop-和-aspectj-aop-有什么区别" class="header-anchor">#</a> 2.3.2 Spring AOP 和 AspectJ AOP 有什么区别？</h3> <p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p> <p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p> <p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p> <h3 id="_2-2-3-aspectj-定义的通知类型有哪些"><a href="#_2-2-3-aspectj-定义的通知类型有哪些" class="header-anchor">#</a> 2.2.3 AspectJ 定义的通知类型有哪些？</h3> <ul><li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li> <li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li> <li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li> <li><strong>AfterThrowing</strong>（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li> <li><strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li></ul> <h3 id="_2-3-4-多个切面的执行顺序如何控制"><a href="#_2-3-4-多个切面的执行顺序如何控制" class="header-anchor">#</a> 2.3.4 多个切面的执行顺序如何控制？</h3> <p>1、通常使用<code>@Order</code> 注解直接定义切面顺序</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 值越小优先级越高</span>
<span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Aspect</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token keyword">implements</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>2、实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Aspect</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token keyword">implements</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span>

    <span class="token comment">// ....</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 返回值越小优先级越高</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="_2-3-5-aop-原理"><a href="#_2-3-5-aop-原理" class="header-anchor">#</a> 2.3.5 AOP 原理</h3> <p>AOP 实际上是由目标类的代理类实现的。AOP 代理其实是由 AOP 框架动态生成的一个对象，该对象可作为目标对象使用。AOP 代理包含了目标对象的全部方法（见图 2-3），但 AOP 代理中的方法与目标对象的方法存在差异，AOP 方法在特定切入点添加了增强处理，并回调了目标对象的方法。</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/dd6f5be29662380983b819737ac4cefe.png" alt="image-20201113011738068"></p> <p>图 2-3
由于是代理实现 AOP，因此有必要学习一下代理。下面通过实例一步一步地了解静态代理和动态代理。新建一个 ServiceImplA 类，实现 IService 接口，想在调用 service 方法前后增加日志打印或为 service 方法增加 try catch，那么该怎么做呢？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>package spring.tutorial.chapter2.AOP;

public interface IService {
    public void service(String name) throws Exception;
}

package spring.tutorial.chapter2.AOP.impl;

public class ServiceImplA implements IService {

    @Override
    public void service(String name) throws Exception {
        System.out.println(&quot;ServiceImplA name&quot;+name);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="_1-在每处调用的地方增加日志和-try-catch"><a href="#_1-在每处调用的地方增加日志和-try-catch" class="header-anchor">#</a> 1．在每处调用的地方增加日志和 try catch</h4> <p>这也是一种方法，但缺点是很明显的，就是每处都要更改，量也会很大，显然不可取。这里是每个点都要加，一个方法可能被调用多处，就要写多次。而且以后再进行修改时也不方便，每个地方都要修改。</p> <h4 id="_2-代理模式"><a href="#_2-代理模式" class="header-anchor">#</a> 2．代理模式</h4> <p>代理模式又分为动态代理模式和静态代理模式。</p> <ul><li>（1）静态代理
静态代理关键是在代理对象和目标对象实现共同的接口，并且代理对象持有目标对象的引用。这里用类 ProxyServiceA 来实现 IService 接口，同时将实现 IService 接口的对象作为一个属性。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>package spring.tutorial.chapter2.AOP.impl;

import spring.tutorial.chapter2.AOP.IService;

public class ProxyServiceA implements IService {

    private IService service;
    public ProxyServiceA(IService service){
        this.service = service;
    }
    @Override
    public void service(String name) throws Exception {
        System.out.println(&quot;log start&quot;);
        try {
            service.service(name);
        }catch (Exception e){
            throw e;
        }
        System.out.println(&quot;log end&quot;);
    }

  public static void main(String[] args) throws Exception {
      IService service = new ServiceImplA();
      service= new ProxyServiceA(service);
      service.service(&quot;CYW&quot;);
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><blockquote><p>输出结果：</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>log start
ServiceImplA nameCYW
log end

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>有了 ProxyServiceA 之后，打印日志和增加 try-catch 只需放在 ProxyServiceA 类里面，便于后续修改，比如现在打印日志是输出在操作台的，哪天需要输入到日志文件时也只需修改 ProxyServiceA 中的打印操作即可。但问题来了：项目中的接口可不止一个，可能会有很多，而且每个接口中的方法也会有好多，这样一个一个地增加也是问题，于是有了动态代理。</p> <ul><li>（2）动态代理
在 Java 的动态代理机制中，有两个重要的类或接口：一个是 InvocationHandler(Interface)，另一个是 Proxy(Class)。这一个类和接口是实现动态代理所必须用到的</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>package spring.tutorial.chapter2.AOP.impl;

public class DynaProxyService implements InvocationHandler {
    private Object target;//目标对象

    public  Object bind(Object object){
        this.target = object;
        //生产动态代理对象
        Object obj = Proxy.newProxyInstance(this.target.getClass().getClassLoader(), this.target.getClass().getInterfaces(), this);
        return  obj;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result = null;
        System.out.println(&quot;method:&quot;+ method);
        System.out.println(&quot;args:&quot;+ args);
        System.out.println(&quot;target:&quot;+ this.target);
        System.out.println(&quot;log start&quot;);
        try {
             result = method.invoke(this.target, args);
        }catch (Exception e){
            throw e;
        }
        System.out.println(&quot;log end&quot;);
        return  result;
    }

    public static void main(String[] args) throws Exception {
        IService service = (IService) new DynaProxyService().bind(new ServiceImplA());
        service.service(&quot;CYM&quot;);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><blockquote><p>输出结果</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>method:public abstract void spring.tutorial.chapter2.AOP.IService.service(java.lang.String) throws java.lang.Exception
args:[Ljava.lang.Object;@1d44bcfa
target:spring.tutorial.chapter2.AOP.impl.ServiceImplA@266474c2
log start
ServiceImplA nameCYM
log end
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>通过 Proxy.newProxyInstance()生成的动态代理对象 A 都会与实现 InvocationHandler 接口的对象 B 关联，动态代理对象 A 调用目标对象方法时都会变成调用 B 中的 invoke 方法。在 invoke 方法中织入增强处理，并通过反射回调目标对象方法。在本例中，通过 bind()生成目标对象 ServiceImplA 的动态代理对象 A，A 关联了实现 InvocationHandler 接口对象的 DynaProxyServiceA，当动态代理对象 A 调用目标对象方法时会执行 DynaProxyServiceA 的 invoke 方法，增加 try-catch、打印日志，并回调目标对象的方法。
与前面的静态代理比较发现，动态代理不用再为每个接口手动创建代理类，其他对象只要与 InvocationHandler 接口对象 bind，就能获得该 InvocationHandler 接口对象的织入增强。</p> <h2 id="_2-4-小结"><a href="#_2-4-小结" class="header-anchor">#</a> 2.4 小结</h2> <p>我们回顾一下这一章节的主要内容，主要了解了 Spring 框架，学习了 IOC、AOP。在 Spring 框架部分，了解了框架的来源、七大模块。在 IOC 部分，介绍了依赖注入、控制反转以及两者的区别，以人与空气为例，使用 Spring 框架演示什么是依赖注入，也对 Spring 有一个大概的认识。在 AOP 部分，主要介绍了横切和纵切的概念、AOP 的概念，并通过实例来了解 AOP 的原理。</p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <p><a href="https://blog.csdn.net/agonie201218/article/details/109731834" target="_blank" rel="noopener noreferrer">Spring Context 你真的懂了吗<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>https://www.cnblogs.com/deveypf/p/11406940.html</p> <p><a href="https://github.com/andanyoung/spring-tutorial" target="_blank" rel="noopener noreferrer">源码下载<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener noreferrer">Spring IOC 容器源码分析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="noopener noreferrer">Spring Bean 的生命周期（非常详细）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>](https://www.cnblogs.com/zrtqsk/p/3735273.html)</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/andanyang/vuepress-theme-vdoing/edit/master/docs/Spring/00002.Spring基础.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/03/24, 03:16:41</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/spring/java/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">第 1 章 Java 基础</div></a> <a href="/pages/ioc/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">第3章 Spring IOC 核心容器</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/spring/java/" class="prev">第 1 章 Java 基础</a></span> <span class="next"><a href="/pages/ioc/">第3章 Spring IOC 核心容器</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/bean-init/"><div>
            面试官必问：说说 Spring Bean 的实例化过程？
            <!----></div></a> <span class="date">03-24</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/circular-dependency/"><div>
            Spring源码最难问题《当Spring AOP遇上循环依赖》
            <!----></div></a> <span class="date">03-24</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/AliasFor/"><div>
            Spring 中@AliasFor注解 详解
            <!----></div></a> <span class="date">03-15</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1218853253@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/andanyang" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2023
    <span>Young | <a href="https://github.com/andanyoung/young-blog/blob/master/LICENSE" target="_blank">MIT License</a> <br/> <a  href="https://beian.miit.gov.cn/" target="_blank">浙ICP备20002744号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.57cec729.js" defer></script><script src="/assets/js/2.fabf76d0.js" defer></script><script src="/assets/js/11.f4e96788.js" defer></script>
  </body>
</html>
