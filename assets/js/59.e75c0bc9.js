(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{842:function(e,s,n){"use strict";n.r(s);var a=n(4),t=Object(a.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("很多人在学习 SPI 的时候将"),s("code",[e._v("@SPI")]),e._v("和"),s("code",[e._v("@Adaptive")]),e._v("注解混在一起学习，最后学得晕晕乎乎看完之后似懂非懂，如果你也有这种困扰，请继续阅读。")]),e._v(" "),s("p",[e._v("并不是说不该将这两个内容一起学习，而是要有个先后顺序再加上自己的推理。是先有 SPI 机制，然后才有的自适应扩展，自适应扩展是基于 SPI 机制的高级特性。")]),e._v(" "),s("h1",{attrs:{id:"为什么需要自适应扩展点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要自适应扩展点"}},[e._v("#")]),e._v(" 为什么需要自适应扩展点")]),e._v(" "),s("p",[e._v("在 Dubbo 中，很多拓展都是通过 SPI 机制进行加载的，比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。这听起来有些矛盾。拓展未被加载，那么拓展方法就无法被调用（静态方法除外）。拓展方法未被调用，拓展就无法被加载。对于这个矛盾的问题，Dubbo 通过自适应拓展机制很好的解决了。")]),e._v(" "),s("p",[e._v("对于这个问题，以之前 demo 为例进行我们进行推演：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('public interface MySPI {\n    void say();\n}\npublic class HelloMySPI implements MySPI{\n    @Override\n    public void say() {\n        System.out.println("HelloMySPI say:hello");\n    }\n}\npublic class GoodbyeMySPI implements MySPI {\n    @Override\n    public void say() {\n        System.out.println("GoodbyeMySPI say:Goodbye");\n    }\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br")])]),s("p",[e._v("现在要增加一个接口 Person，他可以和人打招呼。他有一个实现类是"),s("code",[e._v("Man")]),e._v("，他可以动态的跟人说 hello 或者 goodbye")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public interface Person {\n\n    void greeting();\n}\n\npublic class Man implements Person{\n    private MySPI adaptive;\n\n    public void setAdaptive(MySPI adaptive) {\n        this.adaptive = adaptive;\n    }\n\n    @Override\n    public void greeting(URL url) {\n        adaptive.say(url);\n    }\n\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br")])]),s("p",[e._v("但是"),s("code",[e._v("adaptive")]),e._v("成员要么是"),s("code",[e._v("HelloMySPI")]),e._v("的实例化对象，要么是"),s("code",[e._v("GoodbyeMySPI")]),e._v("的实例化对象，怎么实现动态的去根据需要获取呢？解决这个问题就可以增加一个代理，作为自适应类。所以增加自适应扩展实现如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public class AdaptiveMySPI implements MySPI {\n\n    @Override\n    public void say() {\n        // 1.通过某种方式获得拓展实现的名称\n        String mySpiName;\n\n        // 2.通过 SPI 加载具体的 mySpi\n        MySPI myspi = ExtensionLoader.getExtensionLoader(MySPI.class).getExtension(mySpiName);\n\n        // 3.调用目标方法\n        myspi.say();\n    }\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br")])]),s("p",[e._v("将代理类"),s("code",[e._v("AdaptiveMySPI")]),e._v("作为"),s("code",[e._v("Man")]),e._v("的成员对象，这样就可以实现按需调用了。按需加载如何实现呢？之前我们在"),s("code",[e._v("getExtension()")]),e._v("方法中提到过，只要在根据名字查找的时候，才会按照需要懒加载，所以这个问题天然被 Dubbo SPI 解决了。那么剩下的关键就是如何按需调用，也就是如何获得名字。")]),e._v(" "),s("ol",[s("li",[e._v("可以在当前线程的上下文中获得，比如通过 ThreadLocal 保存。")]),e._v(" "),s("li",[e._v("可以通过接口参数传递，但是这样就需要实现自适应扩展的接口按照约定去定义参数，否则就无法拿到名字，这样对于被代理的接口是有一定限制的。")])]),e._v(" "),s("p",[e._v("Dubbo 用的是第二种方式，也就是他总有办法从参数中动态拿到扩展类名。")]),e._v(" "),s("h1",{attrs:{id:"_2-模拟原理-demo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-模拟原理-demo"}},[e._v("#")]),e._v(" 2.模拟原理 demo")]),e._v(" "),s("p",[e._v("再具体一些 Dubbo 是怎么实现的呢？")]),e._v(" "),s("p",[e._v("自适应拓展机制的实现逻辑比较复杂，首先 Dubbo 会为拓展接口生成具有代理功能的代码。然后通过 javassist 或 jdk 编译这段代码，得到 Class 类。最后再通过反射创建代理类，整个过程比较复杂。为了让大家对自适应拓展有一个感性的认识，按照之前的知识，下面我们继续对之前 demo 为例进行改造：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('@SPI\npublic interface MySPI {\n    void say(URL url);\n}\npublic class HelloMySPI implements MySPI{\n    @Override\n    public void say(URL url) {\n        System.out.println("HelloMySPI say:hello");\n    }\n}\npublic class GoodbyeMySPI implements MySPI {\n    @Override\n    public void say(URL url) {\n        System.out.println("GoodbyeMySPI say:Goodbye");\n    }\n}\npublic class AdaptiveMySPI implements MySPI {\n\n    @Override\n    public void say(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException("url == null");\n        }\n\n        // 1.从 URL 中获取 mySpi 名称\n        String mySpiName = url.getParameter("myspi.type");\n        if (mySpiName == null) {\n            throw new IllegalArgumentException("MySPI == null");\n        }\n\n        // 2.通过 SPI 加载具体的 mySpi\n        MySPI myspi = ExtensionLoader.getExtensionLoader(MySPI.class).getExtension(mySpiName);\n\n        // 3.调用目标方法\n        myspi.say(url);\n    }\n}\n@SPI("man")\npublic interface Person {\n\n    void greeting(URL url);\n}\npublic class Man implements Person {\n    private MySPI adaptive = = ExtensionLoader.getExtensionLoader(MySPI.class).getExtension(“adaptive”);\n\n    public void setAdaptive(MySPI adaptive) {\n        this.adaptive = adaptive;\n    }\n\n    @Override\n    public void greeting(URL url) {\n        adaptive.say(url);\n    }\n}\npublic static void main(String[] args) {\n        ExtensionLoader<Person> extensionLoader = ExtensionLoader.getExtensionLoader(Person.class);\n        Person hello = extensionLoader.getExtension("man");\n        hello.greeting(URL.valueOf("dubbo://192.168.0.101:100?myspi.type=hello"));\n        hello.greeting(URL.valueOf("dubbo://192.168.0.101:100?myspi.type=goodbye"));\n    }\n//输出\nHelloMySPI say:hello\nGoodbyeMySPI say:Goodbye\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br"),s("span",{staticClass:"line-number"},[e._v("50")]),s("br"),s("span",{staticClass:"line-number"},[e._v("51")]),s("br"),s("span",{staticClass:"line-number"},[e._v("52")]),s("br"),s("span",{staticClass:"line-number"},[e._v("53")]),s("br"),s("span",{staticClass:"line-number"},[e._v("54")]),s("br"),s("span",{staticClass:"line-number"},[e._v("55")]),s("br"),s("span",{staticClass:"line-number"},[e._v("56")]),s("br"),s("span",{staticClass:"line-number"},[e._v("57")]),s("br"),s("span",{staticClass:"line-number"},[e._v("58")]),s("br"),s("span",{staticClass:"line-number"},[e._v("59")]),s("br"),s("span",{staticClass:"line-number"},[e._v("60")]),s("br"),s("span",{staticClass:"line-number"},[e._v("61")]),s("br"),s("span",{staticClass:"line-number"},[e._v("62")]),s("br"),s("span",{staticClass:"line-number"},[e._v("63")]),s("br")])]),s("p",[e._v("大家与之前的代码对比就可以发现区别，MySPI 的方法增加了 URL 参数，因为 dubbo 中 url 就是作为一个配置总线贯穿整个调用链路的。这样便可以拿到扩展名，动态调用和加载了。")]),e._v(" "),s("p",[e._v("比如 demo 中的一个 URL")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("dubbo://192.168.0.101:100?myspi.type=hello\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("AdaptiveMySPI 动态的人从 url 中拿到了"),s("code",[e._v("myspi.type=hello")]),e._v("，然后根据 name 拿到了扩展实现，以此完成动态调用。")]),e._v(" "),s("p",[e._v("上面的示例展示了自适应拓展类的核心实现 —- 在拓展接口的方法被调用时，通过 SPI 加载具体的拓展实现类，并调用拓展对象的同名方法。所以接下来的关键就在于，自适应拓展类是如何生成的，Dubbo 是怎么做的。")]),e._v(" "),s("h1",{attrs:{id:"_3-adaptive-注解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-adaptive-注解"}},[e._v("#")]),e._v(" 3.@Adaptive 注解")]),e._v(" "),s("p",[e._v("关于 Dubbo 的自适应扩展，一定避不开这个关键注解"),s("code",[e._v("@Adaptive")]),e._v("。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface Adaptive {\n    String[] value() default {};\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("从上面的代码中可知，Adaptive 可注解在类或方法上。")]),e._v(" "),s("ul",[s("li",[e._v("当 Adaptive 注解在类上时，Dubbo 不会为该类生成代理类。Adaptive 注解在类上的情况很少，在 Dubbo 中，仅有"),s("strong",[e._v("两个")]),e._v("类被 Adaptive 注解了，分别是 "),s("strong",[e._v("AdaptiveCompiler")]),e._v(" 和 "),s("strong",[e._v("AdaptiveExtensionFactory")]),e._v("。此种情况，表示拓展的加载逻辑由人工编码完成。")]),e._v(" "),s("li",[e._v("注解在方法（接口方法）上时，Dubbo 则会为该方法生成代理逻辑。更多时候，Adaptive 是注解在接口方法上的，表示拓展的加载逻辑需由框架自动生成。")])]),e._v(" "),s("p",[e._v("Adaptive 注解的地方不同，相应的处理逻辑也是不同的。注解在类上时，处理逻辑比较简单，本文就不分析了。注解在接口方法上时，处理逻辑较为复杂，本章将会重点分析此块逻辑。")]),e._v(" "),s("h1",{attrs:{id:"_4-源码解读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-源码解读"}},[e._v("#")]),e._v(" 4."),s("strong",[e._v("源码解读")])]),e._v(" "),s("p",[e._v("在 Dubbo 中如何获得一个自适应扩展类呢？只需要一行代码。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('MySPI adaptive = ExtensionLoader.getExtensionLoader(MySPI.class).getAdaptiveExtension();\n@SPI\npublic interface MySPI {\n\n    @Adaptive(value = {"myspi.type"})\n    void say(URL url);\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[s("code",[e._v("getExtensionLoader()")]),e._v("之前我们依旧分析过了，这里直接从"),s("code",[e._v("getAdaptiveExtension()")]),e._v("开始。")]),e._v(" "),s("p",[s("code",[e._v("getAdaptiveExtension()")]),e._v(" 方法是获取自适应拓展的入口方法，首先会检查缓存"),s("code",[e._v("cachedAdaptiveInstance")]),e._v("，缓存未命中，则会执行双重检查，调用 "),s("code",[e._v("createAdaptiveExtension()")]),e._v(" 方法创建自适应拓展。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public T getAdaptiveExtension() {\n    // 从缓存中查找自适应扩展类实例，命中直接返回\n    Object instance = cachedAdaptiveInstance.get();\n   //缓存没有命中\n    if (instance == null) {\n            …… 异常处理\n        //双重检查\n        synchronized (cachedAdaptiveInstance) {\n            instance = cachedAdaptiveInstance.get();\n            if (instance == null) {\n                try {\n                    // 创建自适应实例\n                    instance = createAdaptiveExtension();\n                    cachedAdaptiveInstance.set(instance);\n                } catch (Throwable t) {\n                   …… 异常处理\n    return (T) instance;\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br")])]),s("p",[s("code",[e._v("createAdaptiveExtension()")]),e._v("会首先查找只适应扩展类，然后通过反射进行实例化，再调用"),s("code",[e._v("injectExtension")]),e._v("对扩展实例中注入依赖。")]),e._v(" "),s("p",[e._v("你可能会问直接返回依赖不就行了？为什么还需要注入？")]),e._v(" "),s("p",[e._v("这是因为任何利用 Dubbo SPI 机制加载的用户创建类都是有可能有成员依赖于其他拓展类的，用户实现的自适应扩展类也不例外。而另一种 Dubbo 自己生成的自适应扩展类则不可能出现依赖其他类的情况。")]),e._v(" "),s("p",[e._v("这里只关注重点方法"),s("code",[e._v("getAdaptiveExtensionClass()")]),e._v("。")]),e._v(" "),s("ol",[s("li",[e._v("首先"),s("code",[e._v("getExtensionClasses()")]),e._v("会获取该接口所有的拓展类，")]),e._v(" "),s("li",[e._v("然后会检查缓存是否为空，"),s("code",[e._v("cachedAdaptiveClass")]),e._v("缓存着自适应扩展类的类型。")]),e._v(" "),s("li",[e._v("如果缓存中不存在则调用"),s("code",[e._v("createAdaptiveExtensionClass")]),e._v("开始创建自适应扩展类。")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 用于缓存自适应扩展类的类型\nprivate volatile Class<?> cachedAdaptiveClass = null;\nprivate Class<?> getAdaptiveExtensionClass() {\n    // 加载所有的拓展类配置\n    getExtensionClasses();\n    if (cachedAdaptiveClass != null) {\n        return cachedAdaptiveClass;\n    }\n    // 创建自适应拓展类\n    return cachedAdaptiveClass = createAdaptiveExtensionClass();\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[s("code",[e._v("getExtensionClasses")]),e._v("之前讲过，你肯定会奇怪为什么还需要加载所有扩展类。在这里有个关键逻辑，在调用 loadResource 方法时候会解析@Adaptive 注解，如果被标注了，就表示这个类是一个自适应扩展类实现，会被设置到缓存"),s("code",[e._v("cacheAdaptiveClass")]),e._v("中。")]),e._v(" "),s("p",[e._v("所以有两个原因：")]),e._v(" "),s("p",[e._v("1、是自定义自适应扩展类需要 SPI 机制加载")]),e._v(" "),s("p",[e._v("2、是设置缓存")]),e._v(" "),s("h1",{attrs:{id:"_5-生成自适应扩展类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-生成自适应扩展类"}},[e._v("#")]),e._v(" 5. 生成自适应扩展类")]),e._v(" "),s("p",[e._v("非自己实现的自适应扩展类，都要走"),s("code",[e._v("createAdaptiveExtensionClass")]),e._v("逻辑。")]),e._v(" "),s("p",[e._v("主要逻辑如下：")]),e._v(" "),s("ol",[s("li",[e._v("动态生成自适应扩展类代码")]),e._v(" "),s("li",[e._v("获取类加载器和编译器类（Dubbo 默认使用 javassist 作为编译器）")]),e._v(" "),s("li",[e._v("编译、加载动态生成的类")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("private Class<?> createAdaptiveExtensionClass() {\n    // 动态生成自适应扩展类代码\n    String code = new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();\n    // 获取类加载器\n    ClassLoader classLoader = findClassLoader();\n    // 获取编译器类 ⚠️ AdaptiveCompiler 也是自己定义的\n    org.apache.dubbo.common.compiler.Compiler compiler =  ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();\n    //编译、加载、生产Class\n    return compiler.compile(code, classLoader);\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("p",[e._v("生成自适应扩展类的代码都在"),s("code",[e._v("AdaptiveClassCodeGenerator")]),e._v("中，"),s("code",[e._v("generate()")]),e._v("方法会生成和返回一个自适应扩展类。之前的版本代码其实比较复杂，逻辑都写在了一起，并没有 "),s("code",[e._v("generate")]),e._v(" 方法，进入 Apache 孵化之后对代码结构进行了调整，结构清晰了许多。")]),e._v(" "),s("p",[e._v("主要逻辑如下：")]),e._v(" "),s("ol",[s("li",[e._v("检查接口是否有方法被@Adaptive 修饰。")]),e._v(" "),s("li",[e._v("生产 class 头部的 package 信息。")]),e._v(" "),s("li",[e._v("生成依赖类的 import 信息。")]),e._v(" "),s("li",[e._v("生成方法声明信息。")]),e._v(" "),s("li",[e._v("遍历接口方法依次生成实现方法。")]),e._v(" "),s("li",[e._v("类结束用"),s("code",[e._v("}")]),e._v("收尾，类信息转换为字符串返回。")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('public String generate() {\n    // no need to generate adaptive class since there\'s no adaptive method found.\n    // 检查接口是否有注解了Adaptive的方法，至少需要有一个\n    if (!hasAdaptiveMethod()) {\n        throw new IllegalStateException("No adaptive method exist on extension " + type.getName() + ", refuse to create the adaptive class!");\n    }\n\n    StringBuilder code = new StringBuilder();\n    // 生成package信息\n    code.append(generatePackageInfo());\n    // 生成依赖类的import信息\n    code.append(generateImports());\n    // 生成类的声明信息 public class 接口名$Adaptive implements 接口名\n    code.append(generateClassDeclaration());\n\n    // 遍历接口方法 按需生产实现类\n    Method[] methods = type.getMethods();\n    for (Method method : methods) {\n        code.append(generateMethod(method));\n    }\n  // 类结尾\n    code.append("}");\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(code.toString());\n    }\n  // 转换为字符串返回\n    return code.toString();\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br")])]),s("p",[e._v("下面依次介绍上述步骤的主要逻辑。")]),e._v(" "),s("h4",{attrs:{id:"检查-adaptive-注解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#检查-adaptive-注解"}},[e._v("#")]),e._v(" 检查@Adaptive 注解")]),e._v(" "),s("p",[e._v("遍历接口方法依次检查是否被@Adaptive 标注，至少需要有一个方法被注解，否则抛出异常。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("private boolean hasAdaptiveMethod() {\n    return Arrays.stream(type.getMethods()).anyMatch(m -> m.isAnnotationPresent(Adaptive.class));\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("h4",{attrs:{id:"生成-package-和-import-信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成-package-和-import-信息"}},[e._v("#")]),e._v(" 生成 package 和 import 信息")]),e._v(" "),s("p",[e._v("按照接口的路径名生成对应的 package 信息，并且生成导入信息，目前只是 import 了"),s("code",[e._v("ExtensionLoader")]),e._v("这个类。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('private static final String CODE_PACKAGE = "package %s;\\n";\nprivate String generatePackageInfo() {\n    return String.format(CODE_PACKAGE, type.getPackage().getName());\n}\nprivate static final String CODE_IMPORTS = "import %s;\\n";\nprivate String generateImports() {\n    return String.format(CODE_IMPORTS, ExtensionLoader.class.getName());\n}\n// import org.apache.dubbo.common.extension.ExtensionLoader;\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("h4",{attrs:{id:"生成类的声明信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成类的声明信息"}},[e._v("#")]),e._v(" 生成类的声明信息")]),e._v(" "),s("p",[e._v("生成的类名 = 拓展接口名+$Adaptive，实现的接口就是拓展接口的全限定名。比如 "),s("code",[e._v("public class MySPI$Adaptive implements org.daley.spi.demo.MySPI")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('private String generateClassDeclaration() {\n    return String.format(CODE_CLASS_DECLARATION, type.getSimpleName(), type.getCanonicalName());\n}\nprivate static final String CODE_CLASS_DECLARATION = "public class %s$Adaptive implements %s {\\n";\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("h2",{attrs:{id:"生成方法体"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成方法体"}},[e._v("#")]),e._v(" 生成方法体")]),e._v(" "),s("p",[s("code",[e._v("generateMethod")]),e._v("方法是自适应拓展类生成代理类的核心逻辑所在。它主要会分别拿到方法返回类型、方法名、生成方法体、生成方法参数、生成方法异常，然后按照方法的模板的占位符生成代理方法。很明显，重中之重是生成方法体内容。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("private String generateMethod(Method method) {\n    // 分别拿到方法返回类型、方法名、方法体、方法参数、方法异常\n    String methodReturnType = method.getReturnType().getCanonicalName();\n    String methodName = method.getName();\n    // 生成方法体\n    String methodContent = generateMethodContent(method);\n    String methodArgs = generateMethodArguments(method);\n    String methodThrows = generateMethodThrows(method);\n    // 按照方法模板替换占位符，生成方法内容\n    return String.format(CODE_METHOD_DECLARATION, methodReturnType, methodName, methodArgs, methodThrows, methodContent);\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[s("code",[e._v("generateMethodContent")]),e._v("主要做了如下几件事：")]),e._v(" "),s("ol",[s("li",[e._v("检查是否被@Adaptive 注解，如果没有被注解则生产一段抛出异常的代码。如果被注解，则继续后面逻辑。")]),e._v(" "),s("li",[e._v("找到 URL 类型参数的 index，并且生成检查 URL 参数是否为空的逻辑。")]),e._v(" "),s("li",[e._v("如果没有 URL 参数，则检查是否方法参数有 public 类型无参 get 方法可以直接拿到 URL。")]),e._v(" "),s("li",[e._v("拿到@Adaptive 注解配置的 value，如果没有配置就用接口名默认。")]),e._v(" "),s("li",[e._v("检查是否有 Invocation 类型参数。")]),e._v(" "),s("li",[e._v("根据不同的情况拿到拓展名。")]),e._v(" "),s("li",[e._v("根据扩展名从"),s("code",[e._v("getExtension")]),e._v("中拿到真正的扩展类。")]),e._v(" "),s("li",[e._v("执行扩展类目标方法，按需返回结果。")])]),e._v(" "),s("p",[e._v("这些步骤逻辑都不算复杂，需要格外注意的是第 6 点，这里详细再说明下。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("private String generateMethodContent(Method method) {\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = new StringBuilder(512);\n    // 检查是否被@Adaptive注解\n    if (adaptiveAnnotation == null) {\n        // 不是自适应方法生成的代码是一段抛出异常的代码。\n        return generateUnsupported(method);\n    } else {\n        // 找到 URL.class 类型参数位置\n        int urlTypeIndex = getUrlTypeIndex(method);\n\n        // found parameter in URL type\n        if (urlTypeIndex != -1) {\n            // Null Point check\n            // 找到 URL 生成代码逻辑\n            code.append(generateUrlNullCheck(urlTypeIndex));\n        } else {\n            // did not find parameter in URL type\n            // 未找到 URL 生成代码逻辑\n            // 再找找是否有方法参数有get方法可以返回URL.class的，并且还是不需要入参的public方法\n            code.append(generateUrlAssignmentIndirectly(method));\n        }\n        // 拿到 Adaptive注解的value\n        String[] value = getMethodAdaptiveValue(adaptiveAnnotation);\n\n        // 有 Invocation 类型参数\n        boolean hasInvocation = hasInvocationArgument(method);\n\n        // 检查参数不为null\n        code.append(generateInvocationArgumentNullCheck(method));\n\n        code.append(generateExtNameAssignment(value, hasInvocation));\n        // check extName == null?\n        code.append(generateExtNameNullCheck(value));\n        // getExtension 根据name拿到扩展类\n        code.append(generateExtensionAssignment());\n\n        // return statement 生成方法调用语句并在必要时返回\n        code.append(generateReturnAndInvocation(method));\n    }\n\n    return code.toString();\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br")])]),s("p",[e._v("在"),s("code",[e._v("generateExtNameAssignment")]),e._v("中会有如下几种不同的情况：是否最后一个参数，是否有 Invocation 类型参数、是否配置了名字为"),s("code",[e._v("protocol")]),e._v("的注解 value。")]),e._v(" "),s("p",[e._v("将上面的三种条件组合，生成对应不同的代码，核心其实都是如何正确的从 URL 参数中拿到动态扩展名，具体已做注释。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('private String generateExtNameAssignment(String[] value, boolean hasInvocation) {\n    // TODO: refactor it\n    String getNameCode = null;\n    // 从最后一个开始遍历\n    for (int i = value.length - 1; i >= 0; --i) {\n        if (i == value.length - 1) {\n            // 如果是最后一个参数，设置了默认拓展名\n            if (null != defaultExtName) {\n                // 配置的value不等于"protocol"\n                if (!"protocol".equals(value[i])) {\n                    if (hasInvocation) {\n                        // 有invocation 根据配置名字从url获取getMethodParameter\n                        getNameCode = String.format("url.getMethodParameter(methodName, \\"%s\\", \\"%s\\")", value[i], defaultExtName);\n                    } else {\n                        // 没有invocation，getParameter获取参数\n                        getNameCode = String.format("url.getParameter(\\"%s\\", \\"%s\\")", value[i], defaultExtName);\n                    }\n                } else {\n                    // 直接取协议名\n                    getNameCode = String.format("( url.getProtocol() == null ? \\"%s\\" : url.getProtocol() )", defaultExtName);\n                }\n            } else {\n                //没有设置默认拓展名，和上面的区别就是 没有默认值处理的逻辑。上面获取不到可以直接用默认值。\n                if (!"protocol".equals(value[i])) {\n                    if (hasInvocation) {\n                        getNameCode = String.format("url.getMethodParameter(methodName, \\"%s\\", \\"%s\\")", value[i], defaultExtName);\n                    } else {\n                        getNameCode = String.format("url.getParameter(\\"%s\\")", value[i]);\n                    }\n                } else {\n                    getNameCode = "url.getProtocol()";\n                }\n            }\n        } else {\n            // 如果不是最后一个参数\n            if (!"protocol".equals(value[i])) {\n                if (hasInvocation) {\n                    getNameCode = String.format("url.getMethodParameter(methodName, \\"%s\\", \\"%s\\")", value[i], defaultExtName);\n                } else {\n                    getNameCode = String.format("url.getParameter(\\"%s\\", %s)", value[i], getNameCode);\n                }\n            } else {\n                getNameCode = String.format("url.getProtocol() == null ? (%s) : url.getProtocol()", getNameCode);\n            }\n        }\n    }\n\n    return String.format(CODE_EXT_NAME_ASSIGNMENT, getNameCode);\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br")])]),s("p",[e._v("对于上述条件，可以生成如下几种情况的代码。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('String extName = (url.getProtocol() == null ? "dubbo" : url.getProtocol());\nString extName = url.getMethodParameter(methodName, "loadbalance", "random");\nString extName = url.getParameter("client", url.getParameter("transporter", "netty"));\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("还有一个疑问点是如果有多个参数怎么办？按照代码逻辑，最终的表现效果就是如果有多个参数，且非 Invocation，会生成多层嵌套代码，并且以最外层也就是最左边的参数为准，右边的参数作为默认值。")]),e._v(" "),s("p",[e._v("举个例子：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('@Adaptive(value = {"protocol","param2","myspi.type"})\nvoid say(URL url);\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("生成代码如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('url.getProtocol() == null ? (url.getParameter("param2", url.getParameter("myspi.type"))) : url.getProtocol()\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("当上述一切代码执行完成后，就生成了最终的代理类，并且经过编译和加载最终完成实例化，可以被程序所调用，实现动态按需调用。")]),e._v(" "),s("p",[e._v("最终生成的代理类如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('package org.daley.spi.demo;\nimport org.apache.dubbo.common.extension.ExtensionLoader;\n\npublic class MySPI$Adaptive implements org.daley.spi.demo.MySPI {\n public void say(org.apache.dubbo.common.URL arg0)  {\n if (arg0 == null) throw new IllegalArgumentException("url == null");\n org.apache.dubbo.common.URL url = arg0;\n String extName = url.getProtocol() == null ?(url.getParameter("param2",url.getParameter("myspi.type"))) : url.getProtocol();\n if(extName == null) throw new IllegalStateException("Failed to get extension  (org.daley.spi.demo.MySPI) name from url (" + url.toString() + ") use keys([protocol, param2, myspi.type])");\n org.daley.spi.demo.MySPI extension = (org.daley.spi.demo.MySPI)ExtensionLoader.getExtensionLoader(org.daley.spi.demo.MySPI.class).getExtension(extName);\n extension.say(arg0);\n }\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br")])]),s("p",[e._v("到这里，Dubbo 自适应扩展的原理就讲解结束了。")])])}),[],!1,null,null,null);s.default=t.exports}}]);