(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{358:function(t,e,n){"use strict";n.r(e);var a=n(4),s=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("问：Spring 如何解决循环依赖？\n答：Spring 通过提前曝光机制，利用三级缓存解决循环依赖（这原理还是挺简单的，参考：三级缓存、图解循环依赖原理）\n再问：Spring 通过提前曝光，直接曝光到二级缓存已经可以解决循环依赖问题了，为什么一定要三级缓存？\n再细问：如果循环依赖的时候，所有类又都需要 Spring AOP 自动代理，那 Spring 如何提前曝光？曝光的是原始 bean 还是代理后的 bean？")]),t._v(" "),e("p",[t._v("这些问题算是 Spring 源码的压轴题了，如果这些问题都弄明白，恭喜你顺利结业 Spring 源码了。先上图，再分析源码")]),t._v(" "),e("h1",{attrs:{id:"源码分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码分析"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),e("p",[t._v("进入正题，在 Spring 创建 Bean 的核心代码 doGetBean 中，在实例化 bean 之前，会先尝试从三级缓存获取 bean，这也是 Spring 解决循环依赖的开始")]),t._v(" "),e("h2",{attrs:{id:"一-缓存中获取-bean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-缓存中获取-bean"}},[t._v("#")]),t._v(" (一) 缓存中获取 bean")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// AbstractBeanFactory.java\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n\t\t\t@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n\n\t\tfinal String beanName = transformedBeanName(name);\n\t\tObject bean;\n\n\t\t// 2. 尝试从缓存中获取bean\n\t\tObject sharedInstance = getSingleton(beanName);\n\t\t...\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br")])]),e("p",[t._v("getSingleton:")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\tprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n\t\t// 从一级缓存获取，key=beanName value=bean\n\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\tif (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n\t\t\tsynchronized (this.singletonObjects) {\n\t\t\t\t// 从二级缓存获取，key=beanName value=bean\n\t\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);\n\t\t\t\t// 是否允许循环引用\n\t\t\t\tif (singletonObject == null && allowEarlyReference) {\n\t\t\t\t\t/**\n\t\t\t\t\t * 三级缓存获取，key=beanName value=objectFactory，objectFactory中存储getObject()方法用于获取提前曝光的实例\n\t\t\t\t\t *\n\t\t\t\t\t * 而为什么不直接将实例缓存到二级缓存，而要多此一举将实例先封装到objectFactory中？\n\t\t\t\t\t * 主要关键点在getObject()方法并非直接返回实例，而是对实例又使用\n\t\t\t\t\t * SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference方法对bean进行处理\n\t\t\t\t\t *\n\t\t\t\t\t * 也就是说，当spring中存在该后置处理器，所有的单例bean在实例化后都会被进行提前曝光到三级缓存中，\n\t\t\t\t\t * 但是并不是所有的bean都存在循环依赖，也就是三级缓存到二级缓存的步骤不一定都会被执行，有可能曝光后直接创建完成，没被提前引用过，\n\t\t\t\t\t * 就直接被加入到一级缓存中。因此可以确保只有提前曝光且被引用的bean才会进行该后置处理\n \t\t\t\t\t */\n\t\t\t\t\tObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n\t\t\t\t\tif (singletonFactory != null) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * 通过getObject()方法获取bean，通过此方法获取到的实例不单单是提前曝光出来的实例，\n\t\t\t\t\t\t * 它还经过了SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference方法处理过。\n\t\t\t\t\t\t * 这也正是三级缓存存在的意义，可以通过重写该后置处理器对提前曝光的实例，在被提前引用时进行一些操作\n \t\t\t\t\t\t */\n\t\t\t\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\t\t\t\t// 将三级缓存生产的bean放入二级缓存中\n\t\t\t\t\t\tthis.earlySingletonObjects.put(beanName, singletonObject);\n\t\t\t\t\t\t// 删除三级缓存\n\t\t\t\t\t\tthis.singletonFactories.remove(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn singletonObject;\n\t}\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br"),e("span",{staticClass:"line-number"},[t._v("20")]),e("br"),e("span",{staticClass:"line-number"},[t._v("21")]),e("br"),e("span",{staticClass:"line-number"},[t._v("22")]),e("br"),e("span",{staticClass:"line-number"},[t._v("23")]),e("br"),e("span",{staticClass:"line-number"},[t._v("24")]),e("br"),e("span",{staticClass:"line-number"},[t._v("25")]),e("br"),e("span",{staticClass:"line-number"},[t._v("26")]),e("br"),e("span",{staticClass:"line-number"},[t._v("27")]),e("br"),e("span",{staticClass:"line-number"},[t._v("28")]),e("br"),e("span",{staticClass:"line-number"},[t._v("29")]),e("br"),e("span",{staticClass:"line-number"},[t._v("30")]),e("br"),e("span",{staticClass:"line-number"},[t._v("31")]),e("br"),e("span",{staticClass:"line-number"},[t._v("32")]),e("br"),e("span",{staticClass:"line-number"},[t._v("33")]),e("br"),e("span",{staticClass:"line-number"},[t._v("34")]),e("br"),e("span",{staticClass:"line-number"},[t._v("35")]),e("br"),e("span",{staticClass:"line-number"},[t._v("36")]),e("br"),e("span",{staticClass:"line-number"},[t._v("37")]),e("br"),e("span",{staticClass:"line-number"},[t._v("38")]),e("br"),e("span",{staticClass:"line-number"},[t._v("39")]),e("br")])]),e("h3",{attrs:{id:"三级缓存分别是"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三级缓存分别是"}},[t._v("#")]),t._v(" 三级缓存分别是：")]),t._v(" "),e("p",[e("strong",[t._v("singletonObject：")]),t._v(" 一级缓存，该缓存"),e("code",[t._v("key = beanName, value = bean;")]),t._v("这里的 bean 是已经创建完成的，该 bean 经历过"),e("strong",[t._v("实例化->属性填充->初始化")]),t._v("以及各类的后置处理。因此，一旦需要获取 bean 时，我们第一时间就会寻找一级缓存\n"),e("strong",[t._v("earlySingletonObjects：")]),t._v(" 二级缓存，该缓存"),e("code",[t._v("key = beanName, value = bean;")]),t._v("这里跟一级缓存的区别在于，该缓存所获取到的 bean 是提前曝光出来的，是还没创建完成的。也就是说获取到的 bean 只能确保已经进行了实例化，但是"),e("strong",[t._v("属性填充跟初始化肯定还没有做完")]),t._v("，因此该 bean 还没创建完成，仅仅能作为指针提前曝光，被其他 bean 所引用\n"),e("strong",[t._v("singletonFactories：")]),t._v(" 三级缓存，该缓存"),e("code",[t._v("key = beanName, value = beanFactory;")]),t._v("在 bean 实例化完之后，属性填充以及初始化之前，如果允许提前曝光，spring 会将实例化后的 bean 提前曝光，也就是把该 bean 转换成 beanFactory 并加入到三级缓存。在需要引用提前曝光对象时再通过 singletonFactory.getObject()获取。\n这里抛出问题，如果我们直接将提前曝光的对象放到二级缓存 earlySingletonObjects，Spring 循环依赖时直接取就可以解决循环依赖了，为什么还要三级缓存 singletonFactory 然后再通过 getObject()来获取呢？这不是多此一举？")]),t._v(" "),e("h2",{attrs:{id:"二-三级缓存的添加"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-三级缓存的添加"}},[t._v("#")]),t._v(" (二) 三级缓存的添加")]),t._v(" "),e("p",[t._v("我们回到添加三级缓存，添加 SingletonFactory 的地方，看看 getObject()到底做了什么操作")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("this.addSingletonFactory(beanName, () -> {\n\treturn this.getEarlyBeanReference(beanName, mbd, bean);\n});\n")])])]),e("p",[t._v("可以看到在返回 getObject()时，多做了一步 getEarlyBeanReference 操作，这步操作是 BeanPostProcess 的一种，也就是给子类重写的一个后处理器，目的是用于被提前引用时进行拓展。即：曝光的时候并不调用该后置处理器，只有曝光，且被提前引用的时候才调用，确保了被提前引用这个时机触发。")]),t._v(" "),e("h2",{attrs:{id:"三-提前曝光代理-earlyproxyreferences"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-提前曝光代理-earlyproxyreferences"}},[t._v("#")]),t._v(" (三) 提前曝光代理 earlyProxyReferences")]),t._v(" "),e("p",[t._v("因此所有的重点都落到了 getEarlyBeanReference 上，getEarlyBeanReference 方法是 SmartInstantiationAwareBeanPostProcessor 所规定的接口。再通过 UML 的类图查看实现类，仅有 AbstractAutoProxyCreator 进行了实现。也就是说，除了用户在子类重写，否则仅有 AbstractAutoProxyCreator 一种情况")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("// AbstractAutoProxyCreator.java\npublic Object getEarlyBeanReference(Object bean, String beanName) {\n\t// 缓存当前bean，表示该bean被提前代理了\n\tObject cacheKey = getCacheKey(bean.getClass(), beanName);\n\tthis.earlyProxyReferences.put(cacheKey, bean);\n\t// 对bean进行提前Spring AOP代理\n\treturn wrapIfNecessary(bean, beanName, cacheKey);\n}\n")])])]),e("p",[t._v("wrapIfNecessary 是用于 Spring AOP 自动代理的。Spring 将当前 bean 缓存到 earlyProxyReferences 中标识提前曝光的 bean 在被提前引用之前，然后进行了 Spring AOP 代理。")]),t._v(" "),e("p",[t._v("但是经过 Spring AOP 代理后的 bean 就已经不再是原来的 bean 了，经过代理后的 bean 是一个全新的 bean，也就是说代理前后的 2 个 bean 连内存地址都不一样了。这时将再引出新的问题：B 提前引用 A 将引用到 A 的代理，这是符合常理的，但是最原始的 bean A 在 B 完成创建后将继续创建，那么 Spring Ioc 最后返回的 Bean 是 Bean A 呢还是经过代理后的 Bean 呢？")]),t._v(" "),e("p",[t._v("这个问题我们得回到 Spring AOP 代理，Spring AOP 代理时机有 2 个：")]),t._v(" "),e("p",[t._v("当自定义了 TargetSource，则在 bean 实例化前完成 Spring AOP 代理并且直接发生短路操作，返回 bean\n正常情况下，都是在 bean 初始化后进行 Spring AOP 代理\n如果要加上今天说的提前曝光代理，getEarlyBeanReference 可以说 3 种\n第一种情况就没什么好探究的了，直接短路了，根本没有后续操作。而我们关心的是第二种情况，在 Spring 初始化后置处理器中发生的 Spring AOP 代理")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n\t\tthrows BeansException {\n\n\tObject result = existingBean;\n\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t// 调用bean初始化后置处理器处理\n\t\tObject current = processor.postProcessAfterInitialization(result, beanName);\n\t\tif (current == null) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = current;\n\t}\n\treturn result;\n}\n")])])]),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// AbstractAutoProxyCreator.java\n\tpublic Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {\n\t\tif (bean != null) {\n\t\t\t// 获取缓存key\n\t\t\tObject cacheKey = getCacheKey(bean.getClass(), beanName);\n\t\t\t// 查看该bean是否被Spring AOP提前代理！而缓存的是原始的bean，因此如果bean被提前代理过，这此处会跳过\n\t\t\t// 如果bean没有被提前代理过，则进入AOP代理\n\t\t\tif (this.earlyProxyReferences.remove(cacheKey) != bean) {\n\t\t\t\treturn wrapIfNecessary(bean, beanName, cacheKey);\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br")])]),e("p",[t._v("earlyProxyReferences 是不是有点熟悉，是的，这就是我们刚刚提前曝光并且进行 Spring AOP 提前代理时缓存的原始 bean，如果缓存的原始 bean 跟当前的 bean 是一至的，那么就不进行 Spring AOP 代理了！返回原始的 bean")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\t\ttry {\n\t\t\t//\n\t\t\t/**\n\t\t\t * 4. 填充属性\n\t\t\t * 如果@Autowired注解属性，则在上方完成解析后，在这里完成注入\n\t\t\t *\n\t\t\t * @Autowired\n\t\t\t * private Inner inner;\n\t\t\t */\n\t\t\tpopulateBean(beanName, mbd, instanceWrapper);\n\t\t\t// 5. 初始化\n\t\t\texposedObject = initializeBean(beanName, exposedObject, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n\t\t\t\tthrow (BeanCreationException) ex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);\n\t\t\t}\n\t\t}\n\n\t\t// 6. 存在提前曝光情况下\n\t\tif (earlySingletonExposure) {\n\t\t\t// earlySingletonReference：二级缓存，缓存的是经过提前曝光提前Spring AOP代理的bean\n\t\t\tObject earlySingletonReference = getSingleton(beanName, false);\n\t\t\tif (earlySingletonReference != null) {\n\t\t\t\t// exposedObject跟bean一样，说明初始化操作没用应用Initialization后置处理器(指AOP操作)改变exposedObject\n\t\t\t\t// 主要是因为exposedObject如果提前代理过，就会跳过Spring AOP代理，所以exposedObject没被改变，也就等于bean了\n\t\t\t\tif (exposedObject == bean) {\n\t\t\t\t\t// 将二级缓存中的提前AOP代理的bean赋值给exposedObject，并返回\n\t\t\t\t\texposedObject = earlySingletonReference;\n\t\t\t\t}\n\t\t\t\t// 引用都不相等了，也就是现在的bean已经不是当时提前曝光的bean了\n\t\t\t\telse if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n\t\t\t\t\t// dependentBeans也就是B, C, D\n\t\t\t\t\tString[] dependentBeans = getDependentBeans(beanName);\n\t\t\t\t\tSet<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);\n\t\t\t\t\tfor (String dependentBean : dependentBeans) {\n\t\t\t\t\t\tif (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n\t\t\t\t\t\t\tactualDependentBeans.add(dependentBean);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 被依赖检测异常\n\t\t\t\t\tif (!actualDependentBeans.isEmpty()) {\n\t\t\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName,\n\t\t\t\t\t\t\t\t"Bean with name \'" + beanName + "\' has been injected into other beans [" +\n\t\t\t\t\t\t\t\tStringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n\t\t\t\t\t\t\t\t"] in its raw version as part of a circular reference, but has eventually been " +\n\t\t\t\t\t\t\t\t"wrapped. This means that said other beans do not use the final version of the " +\n\t\t\t\t\t\t\t\t"bean. This is often the result of over-eager type matching - consider using " +\n\t\t\t\t\t\t\t\t"\'getBeanNamesOfType\' with the \'allowEagerInit\' flag turned off, for example.");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br"),e("span",{staticClass:"line-number"},[t._v("20")]),e("br"),e("span",{staticClass:"line-number"},[t._v("21")]),e("br"),e("span",{staticClass:"line-number"},[t._v("22")]),e("br"),e("span",{staticClass:"line-number"},[t._v("23")]),e("br"),e("span",{staticClass:"line-number"},[t._v("24")]),e("br"),e("span",{staticClass:"line-number"},[t._v("25")]),e("br"),e("span",{staticClass:"line-number"},[t._v("26")]),e("br"),e("span",{staticClass:"line-number"},[t._v("27")]),e("br"),e("span",{staticClass:"line-number"},[t._v("28")]),e("br"),e("span",{staticClass:"line-number"},[t._v("29")]),e("br"),e("span",{staticClass:"line-number"},[t._v("30")]),e("br"),e("span",{staticClass:"line-number"},[t._v("31")]),e("br"),e("span",{staticClass:"line-number"},[t._v("32")]),e("br"),e("span",{staticClass:"line-number"},[t._v("33")]),e("br"),e("span",{staticClass:"line-number"},[t._v("34")]),e("br"),e("span",{staticClass:"line-number"},[t._v("35")]),e("br"),e("span",{staticClass:"line-number"},[t._v("36")]),e("br"),e("span",{staticClass:"line-number"},[t._v("37")]),e("br"),e("span",{staticClass:"line-number"},[t._v("38")]),e("br"),e("span",{staticClass:"line-number"},[t._v("39")]),e("br"),e("span",{staticClass:"line-number"},[t._v("40")]),e("br"),e("span",{staticClass:"line-number"},[t._v("41")]),e("br"),e("span",{staticClass:"line-number"},[t._v("42")]),e("br"),e("span",{staticClass:"line-number"},[t._v("43")]),e("br"),e("span",{staticClass:"line-number"},[t._v("44")]),e("br"),e("span",{staticClass:"line-number"},[t._v("45")]),e("br"),e("span",{staticClass:"line-number"},[t._v("46")]),e("br"),e("span",{staticClass:"line-number"},[t._v("47")]),e("br"),e("span",{staticClass:"line-number"},[t._v("48")]),e("br"),e("span",{staticClass:"line-number"},[t._v("49")]),e("br"),e("span",{staticClass:"line-number"},[t._v("50")]),e("br"),e("span",{staticClass:"line-number"},[t._v("51")]),e("br"),e("span",{staticClass:"line-number"},[t._v("52")]),e("br"),e("span",{staticClass:"line-number"},[t._v("53")]),e("br"),e("span",{staticClass:"line-number"},[t._v("54")]),e("br"),e("span",{staticClass:"line-number"},[t._v("55")]),e("br"),e("span",{staticClass:"line-number"},[t._v("56")]),e("br"),e("span",{staticClass:"line-number"},[t._v("57")]),e("br"),e("span",{staticClass:"line-number"},[t._v("58")]),e("br"),e("span",{staticClass:"line-number"},[t._v("59")]),e("br")])]),e("p",[t._v("这个时候我们需要理清一下 3 个变量")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("**earlySingletonReference：**二级缓存，缓存的是经过提前曝光提前 AOP 代理的 bean")])]),t._v(" "),e("li",[e("p",[t._v("bean：这个就是经过了实例化、填充、初始化的 bean")])]),t._v(" "),e("li",[e("p",[t._v("exposedObject：这个是经过了 AbstractAutoProxyCreator 的 postProcessAfterInitialization 处理过后的 bean，但是在其中因为发现当前 bean 已经被 earlyProxyReferences 缓存，所以并没有进行 AOP 处理，而是直接跳过，因此还是跟第 2 点一样的 bean")])])]),t._v(" "),e("p",[t._v("理清这 3 个变量以后，就会发现，exposedObject = earlySingletonReference;\nAOP 代理过的 Bean 赋值给了 exposedObject 并返回，这时候用户拿到的 bean 就是 AOP 代理过后的 bean 了，一切皆大欢喜了。")]),t._v(" "),e("p",[t._v("但是中间还有一个问题！提前曝光的 bean 在提前引用时被 Spring AOP 代理了，但是此时的 bean 只是经过了实例化的 bean，还没有进行@Autowire 的注入啊！也就是说此时代理的 bean 里面自动注入的属性是空的！")]),t._v(" "),e("p",[t._v("(四) 提前 AOP 代理对象的 属性填充、初始化\n是的，确实在 Spring AOP 提前代理后没有经过属性填充和初始化。那么这个代理又是如何保证依赖属性的注入的呢？答案回到 Spring AOP 最早最早讲的 JDK 动态代理上找，JDK 动态代理时，会将目标对象 target 保存在最后生成的代理$proxy中，当调用$proxy 方法时会回调 h.invoke，而 h.invoke 又会回调目标对象 target 的原始方法。因此，其实在 Spring AOP 动态代理时，原始 bean 已经被保存在提前曝光代理中了。而后原始 Bean 继续完成属性填充和初始化操作。因为 AOP 代理$proxy 中保存着 traget 也就是是原始 bean 的引用，因此后续原始 bean 的完善，也就相当于 Spring AOP 中的 target 的完善，这样就保证了 Spring AOP 的属性填充与初始化了！")]),t._v(" "),e("h2",{attrs:{id:"五-循环依赖遇上-spring-aop-图解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五-循环依赖遇上-spring-aop-图解"}},[t._v("#")]),t._v(" (五) 循环依赖遇上 Spring AOP 图解")]),t._v(" "),e("p",[t._v("为了帮助大家理解，这里灵魂画手画张流程图帮助大家理解\n首先又 bean A，bean B，他们循环依赖注入，同时 bean A 还需要被 Spring AOP 代理，例如事务管理或者日志之类的操作。\n原始 bean A，bean B 图中用 a，b 表示，而代理后的 bean A 我们用 aop.a 表示")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200403212201923.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoYWl0b3VkYXJlbg==,size_16,color_FFFFFF,t_70",alt:""}})])])}),[],!1,null,null,null);e.default=s.exports}}]);