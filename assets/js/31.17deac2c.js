(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{356:function(e,a,r){"use strict";r.r(a);var s=r(4),t=Object(s.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"zookeeper-的配置文件详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper-的配置文件详解"}},[e._v("#")]),e._v(" ZooKeeper 的配置文件详解")]),e._v(" "),a("p",[e._v("zkServer.sh 读取的默认配置文件是$ZOOKEEPER_HOME/conf/zoo.cfg。如果要用其它配置文件。如下传递配置文件参数：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("zkServer.sh start  your_config\nzkServer.sh stop   your_config\nzkServer.sh status your_config\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("配置文件的官方说明："),a("a",{attrs:{href:"https://zookeeper.apache.org/doc/r3.6.2/zookeeperAdmin.html#sc_configuration",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://zookeeper.apache.org/doc/r3.6.2/zookeeperAdmin.html#sc_configuration"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("以下是 ZooKeeper 的配置文件中各配置项的解释，分两部分：一部分是 ZooKeeper 正常运行所必须的配置项(只有 3 项)，一部分是非必须项。")]),e._v(" "),a("h1",{attrs:{id:"_1-必须配置项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-必须配置项"}},[e._v("#")]),e._v(" 1.必须配置项")]),e._v(" "),a("p",[e._v("下面 3 项是 ZooKeeper 正常运行所必须配置的。")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("clientPort")]),e._v("：\n向外提供服务的端口号。换句话说，是给客户端连接的端口。")]),e._v(" "),a("li",[a("code",[e._v("dataDir")]),e._v("：\nZooKeeper 的数据目录，主要目的是存储内存数据库序列化后的快照路径。如果没有配置事务日志(即 dataLogDir 配置项)的路径，那么 ZooKeeper 的事务日志也存放在数据目录中。")]),e._v(" "),a("li",[a("code",[e._v("tickTime")]),e._v('：\ntick 的中文意思是"嘀的一声"，tickTime 指的是滴答一声的时间长度。在 ZooKeeper 中，它是所有涉及到时间长度的单元，单位为毫秒，就相当于时钟里的秒单元一样。例如，'),a("code",[e._v("tickTime=2000;initLimit=5")]),e._v('，表示 initLimit 的时间为"嘀嗒"5 次，长度为'),a("code",[e._v("2000*5=10")]),e._v("秒。tickTime 隐含了心跳时间(即心跳时间为 tickTime)，还隐含了客户端和服务器之间保持的会话的最小和最大超时时间(最小 2 倍 tickTime，最大 20 倍 tickTime)。")])]),e._v(" "),a("h1",{attrs:{id:"_2-其它配置项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-其它配置项"}},[e._v("#")]),e._v(" 2.其它配置项")]),e._v(" "),a("h2",{attrs:{id:"_2-1-一般选项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-一般选项"}},[e._v("#")]),e._v(" 2.1 一般选项")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("maxClientCnxns")]),e._v("：\n在套接字级别上限制同一客户端的并发连接数。因为同一客户端 IP 地址相同，可能会调度到同一个 ZooKeeper 服务器节点上。这个配置项是为了避免 DoS 攻击。默认值为 60，设置为 0 表示不做任何限制。")]),e._v(" "),a("li",[a("code",[e._v("clientPortAddress")]),e._v("：\n指定为客户端提供服务的监听地址(ipv4/ipv6)。换句话说，clientPort 将只绑定在地址上。如果不设置该选项，将默认监听在所有地址上(0.0.0.0)。")]),e._v(" "),a("li",[a("code",[e._v("minSessionTimeout")]),e._v("：")]),e._v(" "),a("li",[a("code",[e._v("maxSessionTimeout")]),e._v("：\n客户端和服务端会话保持的最小、最大超时时间。ZooKeeper 的很多数据和状态都和会话绑定。假如客户端和服务端成功建立连接(会话)后，正常情况下，客户端会时不时地向服务端发送心跳，如果这个服务端或者客户端挂了，它们之间的会话要保持多长时间。")]),e._v(" "),a("li",[a("code",[e._v("fsync.warningthresholdms")]),e._v("：\n事务日志输出时，如果调用 fsync 方法超过此处指定的超时时间，那么会在日志中输出警告信息。默认是 1000ms。")]),e._v(" "),a("li",[a("code",[e._v("autopurge.snapRetainCount")]),e._v("：\n该配置项指定开启了 ZooKeeper 的自动清理功能后(见下一个配置项)，每次自动清理时要保留的版本数量。默认值为 3，最小值也为 3。它表示在自动清理时，会保留最近 3 个快照以及这 3 个快照对应的事务日志。其它的所有快照和日志都清理。")]),e._v(" "),a("li",[a("code",[e._v("autopurge.purgeInterval")]),e._v("：\n指定触发自动清理功能的时间间隔，单位为小时，值为大于或等于 1 的整数，默认值为 0，表示不开启自动清理功能。")]),e._v(" "),a("li",[a("code",[e._v("syncEnabled")]),e._v("：\n指定观察者(observers)是否像 follower 一样，也记录事务日志和快照，以便在 observers 重启时能加速恢复。默认值为 true，设置为 false 表示禁用该功能，不记录日志和快照。")])]),e._v(" "),a("h2",{attrs:{id:"_2-2-集群选项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-集群选项"}},[e._v("#")]),e._v(" 2.2 集群选项")]),e._v(" "),a("p",[e._v("在配置 ZooKeeper 集群时可能用到的配置项。")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("electionAlg")]),e._v("：\n指定 leader 选举算法。默认值为 3，表示使用基于 TCP 的快速选举。在以前的版本中，还有 0/1/2 三种算法，它们都是基于 UDP 的，已经废弃了，以后的版本中会移除这三种算法。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("initLimit")]),e._v("：\nfollowers 启动时需要连接 leader，并从 Leader 处获取它所缺失的那部分数据，以便它能和 leader 的数据保持同步。只有保持了同步，该 follower 才被标记为 ONLINE，然后才能提供服务。这个配置项限定从 follower 启动到恢复完成的超时时间。一般情况下，ZooKeeper 保存的都是协调数据，数据量不会很大，但如果要同步的数据很大，可以考虑增大这个选项的值。注意，这个值依赖于 tickTime 时间单元，例如"),a("code",[e._v("tickTime=2000,initLimit=2")]),e._v("表示 4 秒。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("syncLimit")]),e._v("：\nfollower 和 leader 之间数据延迟的最大时间长度。例如，有个节点的更新操作缓慢，它的数据已经严重落后于 leader，ZooKeeper 就会将它从 ZooKeeper 集群中踢出去。ZooKeeper 使用时间来度量 follower 和 leader 之间数据的延迟，这个选项的值依赖于 tickTime，例如"),a("code",[e._v("tickTime=2000,syncLimit=2")]),e._v("表示 follower 比 leader 延迟了 4 秒。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("leaderServes")]),e._v("：\n默认值为 yes，表示 leader 也接受客户端的连接，接受来自客户端的读、写请求。leader 的主要作用是协调 ZooKeeper 集群服务器节点间的写操作，如果想要获取更高的写吞吐量，可以将其设置为 no，这样 leader 将不允许客户端的连接，它将专注于协调，但这会损失一点读吞吐量。")])]),e._v(" "),a("li",[a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("server.x=[hostname]:port_A:port_B\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("指定 ZooKeeper 集群中的服务器节点。有几个 server 节点，就给几个这个配置项，所有节点上的这部分配置要一致。")]),e._v(" "),a("ul",[a("li",[e._v("X：整数。是 ZooKeeper 中服务器的一个简单标识。这个数值需要和 dataDir 下的 myid 文件内容一致。在启动 ZooKeeper 集群中的每个实例时，需要读取 dataDir 中的 myid 文件，并将该文件中的数值和配置文件中的 server.X 做匹配，匹配到哪个就表示是哪个 ZooKeeper 服务器节点。")]),e._v(" "),a("li",[e._v("hostname：ZooKeeper 服务器节点的地址。")]),e._v(" "),a("li",[e._v("port_A：这是第一个端口，用于 Follower 和 Leader 之间的数据同步和其它通信。")]),e._v(" "),a("li",[e._v("port_B：这是第二个端口，用于 Leader 选举过程中投票通信。")])]),e._v(" "),a("p",[e._v("如果要配置的 ZooKeeper 的伪集群(多个 ZooKeeper 实例运行在同一机器上)，每个 server.X 中的 X、port_A 和 port_B 必须不能相同。")]),e._v(" "),a("p",[e._v("例如，3 个服务器节点的伪集群 ZooKeeper，数据目录分别为/zk/data1，/zk/data2，/zk/data3。可以这样配置。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("server.1=localhost:2881:3881\nserver.2=localhost:2882:3882\nserver.3=localhost:2883:3883\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("然后在 data1/myid、data2/myid、data3/myid 中分别写入 1、2、3(需要和 X 值对应)。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("group.x=A[:B]")]),e._v("：")])]),e._v(" "),a("li",[a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("weight.y=N\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("这两个一起用，用于启用分层仲裁功能。group 命令用于将 ZooKeeper 集群中的服务器节点进行分组。如果没有使用 group 选项，则 ZooKeeper 默认将所有服务器节点归入一个默认组中。weight 命令用于为每个服务器节点指定权重值，权重越高，投票时能投的票数越多。如果不配置 weight 命令，则所有节点的默认权重值为 1。")]),e._v(" "),a("ul",[a("li",[e._v("x：分组 id。整数值。")]),e._v(" "),a("li",[e._v("A:B:C...：用冒号分隔的服务器节点列表，表示这几个节点属于同一个组。整数值，取自 server.X 中的 X。例如，上面 server.x 中的示例，"),a("code",[e._v("group.1=1:2:3")]),e._v("表示将这 3 个节点放进一个 id=1 的组中。")]),e._v(" "),a("li",[e._v("y：取自 server.X 中的 X。")]),e._v(" "),a("li",[e._v("N：为该服务器节点指定的权重值。\n例如，9 个节点的 ZooKeeper 集群，分成 3 组：")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("server.1=aaaa\nserver.2=aaaa\nserver.3=aaaa\nserver.4=aaaa\nserver.5=aaaa\nserver.6=aaaa\nserver.7=aaaa\nserver.8=aaaa\nserver.9=aaaa\n　\ngroup.1=1:2:3\ngroup.2=4:5:6\ngroup.3=7:8:9\n　\nweight.1=1\nweight.2=1\nweight.3=1\nweight.4=1\nweight.5=1\nweight.6=1\nweight.7=1\nweight.8=1\nweight.9=1\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br")])]),a("p",[e._v("当需要仲裁时，首先过滤掉权重值为 0 的组(即组中所有节点权重都为 0)，然后判断，如果组中有大多数节点投票的组达到了大多数组的要求，仲裁就通过。换个理解方式，就是先在组内投票，然后组自身投票。组内投票数达到了该组的大多数，这个组就有一票。如果投票的组数量达到了总组数的大多数(不考虑权重为 0 的组)，则整个仲裁就通过。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("cnxTimeout")]),e._v("：\n在投票选举新的 leader 时，需要通过选举端口建立连接来发送通知信息。该配置项设置打开这个连接的超时时长。默认值为 5。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("ipReachableTimeout")]),e._v("：\n3.4.11 版本中才引入的配置项。当解析主机名时，为可访问的 IP 地址设置此超时值，单位毫秒。默认情况下，ZooKeeper 将使用主机名的第一个 IP 地址(不做任何 reachable 检查)。设置 ipReachableTimeout(大于 0)后，ZooKeeper 将尝试获取第一个可访问的 IP 地址。这是通过调用 Java API 函数"),a("code",[e._v("InetAddress.isreavailable(long timeout)")]),e._v("实现的。其中使用了这个超时值。如果找不到这样的 IP 地址，主机名的第一个 IP 地址将被使用。")])])]),e._v(" "),a("h1",{attrs:{id:"_3-事务日志和快照"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-事务日志和快照"}},[e._v("#")]),e._v(" 3. 事务日志和快照")]),e._v(" "),a("blockquote",[a("p",[e._v("ZooKeeper 有两种日志、一种快照。日志分为事务日志和 ZooKeeper 运行时的系统日志。")])]),e._v(" "),a("p",[e._v("ZooKeeper 集群中的每个服务器节点每次"),a("strong",[e._v("接收到写操作请求时，都会先将这次请求发送给 leader，leader 将这次写操作转换为带有状态的事务，然后 leader 会对这次写操作广播出去以便进行协调。当协调通过(大多数节点允许这次写)后，leader 通知所有的服务器节点，让它们将这次写操作应用到内存数据库中，并将其记录到事务日志中。")])]),e._v(" "),a("p",[e._v('当事务日志记录的次数达到一定数量后(默认 10W 次)，就会将内存数据库序列化一次，使其持久化保存到磁盘上，序列化后的文件称为"快照文件"。每次拍快照都会生成新的事务日志。')]),e._v(" "),a("p",[e._v("有了事务日志和快照，就可以让任意节点恢复到任意时间点(只要没有清理事务日志和快照)。")]),e._v(" "),a("h2",{attrs:{id:"_3-1-事务日志和快照相关的配置项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-事务日志和快照相关的配置项"}},[e._v("#")]),e._v(" 3.1 事务日志和快照相关的配置项")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("dataDir")]),e._v("：\nZooKeeper 的数据目录，主要目的是存储内存数据库序列化后的快照路径。如果没有配置事务日志(即 dataLogDir 配置项)的路径，那么 ZooKeeper 的事务日志也存放在数据目录中。")]),e._v(" "),a("li",[a("code",[e._v("dataLogDir")]),e._v("：\n指定事务日志的存放目录。"),a("strong",[e._v("事务日志对 ZooKeeper 的影响非常大，强烈建议事务日志目录和数据目录分开")]),e._v("，不要将事务日志记录在数据目录(主要用来存放内存数据库快照)下。")]),e._v(" "),a("li",[a("code",[e._v("preAllocSize")]),e._v("：\n为事务日志预先开辟磁盘空间。默认是 64M，意味着每个事务日志大小就是 64M(可以去事务日志目录中看一下，每个事务日志只要被创建出来，就是 64M)。如果 ZooKeeper 产生快照频率较大，可以考虑减小这个参数，因为每次快照后都会切换到新的事务日志，但前面的 64M 根本就没写完。(见 snapCount 配置项)")]),e._v(" "),a("li",[a("code",[e._v("snapCount")]),e._v("：\nZooKeeper 使用事务日志和快照来持久化每个事务(注意是日志先写)。该配置项指定 ZooKeeper 在将内存数据库序列化为快照之前，需要先写多少次事务日志。也就是说，每写几次事务日志，就快照一次。默认值为 100000。为了防止所有的 ZooKeeper 服务器节点同时生成快照(一般情况下，所有实例的配置文件是完全相同的)，当某节点的先写事务数量在(snapCount/2+1,snapCount)范围内时(挑选一个随机值)，这个值就是该节点拍快照的时机。")]),e._v(" "),a("li",[a("code",[e._v("autopurge.snapRetainCount")]),e._v("：\n该配置项指定开启了 ZooKeeper 的自动清理功能后(见下一个配置项)，每次自动清理时要保留的版本数量。默认值为 3，最小值也为 3。它表示在自动清理时，会保留最近 3 个快照以及这 3 个快照对应的事务日志。其它的所有快照和日志都清理。")]),e._v(" "),a("li",[a("code",[e._v("autopurge.purgeInterval")]),e._v("：\n指定触发自动清理功能的时间间隔，单位为小时，值为大于或等于 1 的整数，默认值为 0，表示不开启自动清理功能。")])]),e._v(" "),a("h2",{attrs:{id:"_3-2-事务日志和快照的命名规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-事务日志和快照的命名规则"}},[e._v("#")]),e._v(" 3.2 事务日志和快照的命名规则")]),e._v(" "),a("p",[e._v("在 ZooKeeper 集群启动后，当第一个客户端连接到某个服务器节点时，会创建一个会话，这个会话也是事务，于是创建第一个事务日志，一般名为"),a("code",[e._v("log.100000001")]),e._v("，这里的 100000001 是这次会话的事务 id(zxid)。之后的事务都将写入到这个文件中，直到拍下一个快照。")]),e._v(" "),a("p",[e._v("如果是事务 ZXID5 触发的拍快照，那么快照名就是 snapshot.ZXID5，拍完后，下一个事务的 ID 就是 ZXID6，于是新的事务日志名为 log.ZXID6。")])])}),[],!1,null,null,null);a.default=t.exports}}]);