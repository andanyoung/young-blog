(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{1035:function(n,s,e){"use strict";e.r(s);var t=e(4),a=Object(t.a)({},(function(){var n=this,s=n._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"第-4-章-spring-之-aop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第-4-章-spring-之-aop"}},[n._v("#")]),n._v(" 第 4 章 Spring 之 AOP")]),n._v(" "),s("blockquote",[s("p",[n._v("在上一章节中，我们大致了解了 Spring 核心容器，了解了 IOC 思想在 Spring 中的具体应用 Bean 容器以及 Bean 的配置与使用，这一章我们将开始学习 AOP 在 Spring 框架中的具体应用。")])]),n._v(" "),s("p",[n._v("本章主要涉及的知识点：")]),n._v(" "),s("ul",[s("li",[n._v("AOP 的引入：从传统处理方法到 AOP 处理，一步一步引入。")]),n._v(" "),s("li",[n._v("AOP 的实现方式：通过实践了解 AOP 的 3 种实现方式。")])]),n._v(" "),s("h2",{attrs:{id:"_4-1-aop-基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-aop-基础"}},[n._v("#")]),n._v(" 4.1 AOP 基础")]),n._v(" "),s("p",[n._v("在第 2 章中也有介绍 AOP，不过侧重点是 AOP 的原理和动态代理，本节主要介绍 AOP 的基础知识点。")]),n._v(" "),s("h3",{attrs:{id:"_4-1-1-aop-的引入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-1-aop-的引入"}},[n._v("#")]),n._v(" 4.1.1 AOP 的引入")]),n._v(" "),s("p",[n._v("这里可以把单个模块当作一个圆柱，假如没有 AOP，那么在做日志处理的时候，我们就会在每个模块中添加日志或者权限处理，日志或权限类似圆柱体的部分圆柱，如图 4-1 所示。\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/fc52c72eff752a2ddb14ed3c3e095520.png",alt:"图4-1"}}),n._v("\n图 4-1")]),n._v(" "),s("p",[n._v("一般大多数的日志或权限处理代码是相同的，为了实现代码复用，我们可能把日志处理抽离成一个新的方法，如图 4-2 所示。")]),n._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/5a6f6518a902e30dc035cbfb83f82b5c.png",alt:"图4-2"}})]),n._v(" "),s("p",[n._v("图 4-2")]),n._v(" "),s("p",[n._v("即使这样，我们仍然必须手动插入这些方法，而且这两个方法是强耦合的。假如此时我们不需要这个功能了，或者想换成其他功能，就必须一个个修改。\n通过动态代理，可以在指定位置执行对应流程。这样就可以将一些横向的功能抽离出来，形成一个独立的模块，然后在指定位置插入这些功能。这样的思想被称为面向切面编程，亦即 AOP，如图 4-3 所示。")]),n._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/5d5cdde6daaa8d515188a5313a6d6520.png",alt:"图4-3"}})]),n._v(" "),s("h3",{attrs:{id:"_4-1-2-aop-主要概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-2-aop-主要概念"}},[n._v("#")]),n._v(" 4.1.2 AOP 主要概念")]),n._v(" "),s("p",[n._v("4.1.1 小节介绍了引入 AOP 的好处，本小节来了解一下 AOP 的几个核心概念。")]),n._v(" "),s("ul",[s("li",[s("p",[n._v("（1）横切关注点\nAOP 把一个业务流程分成几部分，例如权限检查、业务处理、日志记录，每个部分单独处理，然后把它们组装成完整的业务流，每部分被称为切面或关注点。")])]),n._v(" "),s("li",[s("p",[n._v("（2）切面\n类是对物体特征的抽象，切面就是对横切关注点的抽象。可以将每部分抽象成一叠纸一样，一层一层的，那么每张纸都是一个切面。")])]),n._v(" "),s("li",[s("p",[n._v("（3）连接点\n因为 Spring 只支持方法类型的连接点，所以在 Spring 中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。其实，Spring 只支持方法类型的连接点包含字段和构造器。因为字段通过 get、set 方法得到，构造器其实也是方法。Spring 只支持方法类型的连接点和连接点是字段或者构造器是包含关系。")])]),n._v(" "),s("li",[s("p",[n._v("（4）切入点\n对连接点进行拦截的定义。连接点可以有很多，但并不一定每个连接点都进行操作，比如莲藕，藕段与藕段之间是有连接点的，但不一定都切开。")])]),n._v(" "),s("li",[s("p",[n._v("（5）通知")]),n._v(" "),s("p",[n._v("通知指的就是指拦截到连接点之后要执行的代码，分为前置、后置、异常、最终、环绕通知 5 类。这个有点类似于把藕段与藕段断开之后要做的事情，是往里面加蜂蜜还是做什么。")])]),n._v(" "),s("li",[s("p",[n._v("（6）目标对象\n代理的目标对象，就是动态代理的 target，在实际操作中一般会先实现 AOP 的接口，然后配置这些接口作用到哪些对象上，被作用的对象就是目标对象。")])]),n._v(" "),s("li",[s("p",[n._v("（7）织入\n切面是独立的，目标对象也是独立的，它们是不耦合的，那它怎么把切面放到目标对象中呢？这时就需要进行织入操作，就类似这种的，怎么把 target 和打印日志联系到一起呢？使用动态代理。在 Spring 中，aop.framework.ProxyFactory 用作织入器，进行横切逻辑的织入。")])]),n._v(" "),s("li",[s("p",[n._v("（8）引入\n不改代码的同时，为类动态地添加方法或字段。")])])]),n._v(" "),s("h2",{attrs:{id:"_4-2-aop-实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-aop-实现"}},[n._v("#")]),n._v(" 4.2 AOP 实现")]),n._v(" "),s("p",[n._v("4.1 节主要介绍了 AOP 的理论知识，本节通过示例进一步理解 Spring 中 AOP 的使用，主要介绍 AOP 的 3 种实现方式：经典的基于代理的 AOP、AspectJ 基于 XML 的配置、AspectJ 基于注解的配置。")]),n._v(" "),s("h4",{attrs:{id:"_1-经典的基于代理的-aop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-经典的基于代理的-aop"}},[n._v("#")]),n._v(" 1．经典的基于代理的 AOP")]),n._v(" "),s("p",[n._v("基于代理的 AOP 主要介绍 MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice 三个接口的使用。")]),n._v(" "),s("ul",[s("li",[n._v("MethodBeforeAdvice：见名知意，通过方法名就可以猜到它的作用。方法前拦截器在执行指定方法前调用，参数分别为被调用的方法、执行时被传入的参数、被拦截的 Bean。")]),n._v(" "),s("li",[n._v("AfterReturningAdvice：返回后拦截器，在执行完指定方法并返回之后调用。如果有返回值可以获取到返回值，否则为 null。参数分别为方法返回值、被调用的方法、执行时被传入的参数、被拦截的 Bean。")]),n._v(" "),s("li",[n._v("ThrowsAdvice：异常拦截器，在指定方法抛出异常时被调用。该接口并未定义方法，因此不需要实现任何方法。那它是怎么拦截的呢？我们可以查看该接口的定义，在定义类文档中有如图 4-4 所示的说明。例如，在实现该接口的类中定义了 public void afterThrowing(Exception ex)、public void afterThrowing(Method method, Object[] args, Object target, Exception ex)方法抛出异常时就会被调用。\n[插图]\n图 4-4")])]),n._v(" "),s("p",[n._v("在软件开发中推荐面向接口的编程，所以这里创建一个 IAOPServices 接口，并定义两个方法：withAopMethod 方法将使用拦截器拦截的方法，withNoAopMethod 方法不会被拦截器拦截。接口代码如下：")]),n._v(" "),s("p",[n._v("在软件开发中推荐面向接口的编程，所以这里创建一个 IAOPServices 接口，并定义两个方法：withAopMethod 方法将使用拦截器拦截的方法，withNoAopMethod 方法不会被拦截器拦截。接口代码如下：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("public interface IAOPService {\n    public String withAopMethod() throws Exception;\n\n    public String withNoAopMethod() throws Exception;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br")])]),s("p",[n._v("在 AOPServicesImpl 类中实现了该接口，并在该类中定义了 String 类型的 description 属性，以及对应的 getter、setter 方法。两个接口方法将返回该 description 属性的值。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('public class AOPServicesImpl implements IAOPService {\n    private String description;\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public String withAopMethod() throws Exception {\n        System.out.println("AOP函数运行方法:withAopMethod");\n        if(description.trim().length()==0){\n            throw new Exception("description为空");\n        }\n        return description;\n    }\n\n    public String withNoAopMethod() throws Exception {\n        System.out.println("无AOP函数运行方法:withNoAopMethod");\n        return description;\n    }\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br")])]),s("p",[n._v("上面把要使用 AOP 拦截的方法准备好了，下面就是定义 AOP 拦截器方法了。这里在 AOPInterceptor 类中实现了上面的 AfterReturningAdvice、MethodBeforeAdvice、ThrowsAdvice 三个接口。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('public class AOPInterceptor  implements AfterReturningAdvice,MethodBeforeAdvice,ThrowsAdvice{\n    public void afterReturning(Object value, Method method, Object[] args, Object instance) throws Throwable {\n\n        System.out.println("方法"+method.getName()+"运行结束,返回值为:"+value);\n    }\n\n    public void before(Method method, Object[] args, Object instance) throws Throwable {\n        System.out.println("ִ执行MethodBeforeAdvice,即将执行的方法:"+method.getName());\n        if(instance instanceof AOPServicesImpl)\n        {\n            String description=((AOPServicesImpl)instance).getDescription();\n            if(description==null)\n            {\n                throw new NullPointerException("description为 null");\n            }\n        }\n    }\n    public void afterThrowing(Exception ex){\n        System.out.println("抛出异常："+ex.getMessage());\n    }\n\n    public void afterThrowing(Method method, Object[] args, Object target, Exception ex){\n        System.out.println("方法"+method.getName()+"抛出异常："+ex.getMessage());\n    }\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br")])]),s("p",[n._v("这里要拦截的方法和拦截器都准备好了，怎么将拦截器用于拦截该方法呢？这里就需要进行配置了。首先在 pom.xml 中引入依赖，这里引入 spring-aop、spring-context。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>chapter4</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <spring.version>5.0.0.RELEASE</spring.version>\n    </properties>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n    </dependencies>\n</project>\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br")])]),s("p",[n._v("实际上 Spring 无法将 Services 实现类与拦截器直接组装，因为没有对应的 setter、getter 方法。安装时，先借助 Spring 中的代理类将自定义拦截器注入 NameMatchMethodPointcutAdvisor 类的 advice 属性中，再将定义好的 NameMatchMethodPointcutAdvisor 对象注入 ProxyFactoryBean 中。这里将自定义的 AOPInterceptor 拦截器注入 NameMatchMethodPointcutAdvisor 中，然后将 NameMatchMethodPointcutAdvisor 对象注入 ProxyFactoryBean 中。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="aopInterceptor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">\n        <property name="advice">\n            <bean class="spring.tutorial.chapter4.aop.AOPInterceptor"></bean>\n        </property>\n        <property name="mappedName" value="withAopMethod"></property>\n    </bean>\n\n    <bean id="aopService" class="org.springframework.aop.framework.ProxyFactoryBean">\n        <property name="interceptorNames">\n            <list>\n                <value>aopInterceptor</value>\n            </list>\n        </property>\n        <property name="target">\n            <bean class="spring.tutorial.chapter4.service.impl.AOPServicesImpl">\n                <property name="description" value="basicAop"></property>\n            </bean>\n        </property>\n    </bean>\n</beans>\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br")])]),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("从Spring容器中获取IAOPServices对象，并分别执行IAOPServices中的两个方法。Spring会在withAopMethod()方法前后添加拦截器，在withNoAopMethod()方法前后并不会添加。\n")])])]),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('public class Chapter4Controller {\n  public static void main(String[] args) throws Exception {\n      ApplicationContext context=new ClassPathXmlApplicationContext(new String[]{"applicationContext.xml"});\n      BeanFactory factory=context;\n      IAOPService services=(IAOPService)context.getBean("aopService");\n      services.withAopMethod();\n      services.withNoAopMethod();\n  }\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br")])]),s("blockquote",[s("p",[n._v("运行结果如下：")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("ִ执行MethodBeforeAdvice,即将执行的方法:withAopMethod\nAOP函数运行方法:withAopMethod\n方法withAopMethod运行结束,返回值为:basicAop\n无AOP函数运行方法:withNoAopMethod\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br")])]),s("h4",{attrs:{id:"_2-aspectj-基于-xml-的配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-aspectj-基于-xml-的配置"}},[n._v("#")]),n._v(" 2．AspectJ 基于 XML 的配置")]),n._v(" "),s("p",[n._v("AspectJ 是一个面向切面的框架，扩展了 Java 语言。AspectJ 定义了 AOP 语法，有一个专门的编译器，用来生成遵守 Java 字节编码规范的 Class 文件。我们还是利用 IAOPServices 接口、AOPServicesImpl 类实现 AspectJ 基于 XML 的 AOP 编程。表 4-1 给出 AspectJ 主要的配置元素。使用 AspectJ 时需要引入两个依赖项，即 aopalliance、aspectjweaver。在引入这两个依赖项时需要注意，有时会报错，更新两个依赖项的版本就好了。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("\t<dependency>\n\t    <groupId>aopalliance</groupId>\n\t    <artifactId>aopalliance</artifactId>\n\t    <version>1.0</version>\n\t</dependency>\n    \x3c!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\x3e\n\t<dependency>\n\t    <groupId>org.aspectj</groupId>\n\t    <artifactId>aspectjweaver</artifactId>\n\t    <version>1.8.11</version>\n\t</dependency>\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br")])]),s("p",[n._v("表 4-1 AspectJ 主要的配置元素\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/5a8815767dae0e7f8ca245af31013c26.png",alt:"image-20201125004430038"}})]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("这里里定义了XMLAdvice拦截器方法，用于演示前置、后置、成功返回、异常返回、环绕通知。\n")])])]),s("p",[n._v("上面把拦截器定义完了，之后就是把定义好的拦截器与 Services 关联在一起。使用 AOP 配置元素将 Services 与拦截器中的方法关联上。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('import org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\n\n\npublic class XMLAdvice {\n    public void beforeAdvice() {\n        System.out.println("前置通知执行了");\n    }\n\n    public void afterAdvice() {\n        System.out.println("后置通知执行了");\n    }\n\n    public void afterReturnAdvice(String result) {\n        System.out.println("返回通知执行了" + "运行业务方法返回的结果为" + result);\n    }\n\n    public String aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n        String result = "";\n        try {\n            System.out.println("环绕通知开始执行了");\n            long start = System.currentTimeMillis();\n            result = (String) proceedingJoinPoint.proceed();\n            long end = System.currentTimeMillis();\n            System.out.println("环绕通知执行结束了");\n            System.out.println("执行业务方法共计：" + (end - start) + "毫秒。");\n        } catch (Throwable e) {\n\n        }\n        return result;\n    }\n\n    public void throwingAdvice(JoinPoint joinPoint, Exception e) {\n        StringBuffer stringBuffer = new StringBuffer();\n        stringBuffer.append("异常通知执行了.");\n        stringBuffer.append("方法:").append(joinPoint.getSignature().getName()).append("出现了异常.");\n        stringBuffer.append("异常信息为:").append(e.getMessage());\n        System.out.println(stringBuffer.toString());\n    }\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br")])]),s("p",[n._v("上面把拦截器定义完了，之后就是把定义好的拦截器与 Services 关联在一起。使用 AOP 配置元素将 Services 与拦截器中的方法关联上。")]),n._v(" "),s("p",[n._v("配置完之后还是和经典的基于代理的 AOP 一样，运行代码从 Spring 容器中获取 IAOPServices 对象，并分别执行 IAOPServices 中的两个方法。Spring 会在 withAopMethod()方法前后添加拦截器，在 withNoAopMethod()方法前后并不会添加。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <bean id="serviceImplA" class="spring.tutorial.chapter4.service.impl.AOPServicesImpl">\n        <property name="description" value="basicAop"></property>\n    </bean>\n\n    <bean id="serviceAspectBean" class="spring.tutorial.chapter4.service.impl.XMLAdvice" />\n    <aop:config>\n        <aop:aspect id="serviceAspect" ref="serviceAspectBean">\n            <aop:pointcut id="servicePointcut" expression="execution(* spring.tutorial.chapter4.service.*.withAop*(..))" />\n            <aop:before pointcut-ref="servicePointcut" method="beforeAdvice" />\n            <aop:after pointcut-ref="servicePointcut" method="afterAdvice" />\n            <aop:after-returning pointcut-ref="servicePointcut" method="afterReturnAdvice" returning="result" />\n            <aop:around pointcut-ref="servicePointcut" method="aroundAdvice" />\n            <aop:after-throwing pointcut-ref="servicePointcut" method="throwingAdvice" throwing="e" />\n        </aop:aspect>\n    </aop:config>\n</beans>\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br")])]),s("p",[n._v("配置完之后还是和经典的基于代理的 AOP 一样，运行代码从 Spring 容器中获取 IAOPServices 对象，并分别执行 IAOPServices 中的两个方法。Spring 会在 withAopMethod()方法前后添加拦截器，在 withNoAopMethod()方法前后并不会添加。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('ApplicationContext context =\n        new ClassPathXmlApplicationContext(new String[] {"ajApplicationContext.xml"});\n    BeanFactory factory = context;\n    IAOPService services = (IAOPService) context.getBean("serviceImplA");\n    services.withAopMethod();\n    services.withNoAopMethod();\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br")])]),s("blockquote",[s("p",[n._v("运行结果如下")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("前置通知执行了\n环绕通知开始执行了\nAOP函数运行方法:withAopMethod\n环绕通知执行结束了\n执行业务方法共计：0毫秒。\n返回通知执行了运行业务方法返回的结果为basicAop\n后置通知执行了\n无AOP函数运行方法:withNoAopMethod\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br")])]),s("h4",{attrs:{id:"_3-aspectj-基于注解的配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-aspectj-基于注解的配置"}},[n._v("#")]),n._v(" 3．AspectJ 基于注解的配置")]),n._v(" "),s("p",[n._v("AspectJ 基于 XML 的配置还是需要在 XML 中配置 AOP 元素。现在一般提倡使用注解来进行编程，AspectJ 也提供了基于注解的实现方式。基于注解的 AOP 配置其实和基于 XML 的一样，可以参照基于 XML 的来进行理解。这里定义了 AnnontationAdvice，并用@Aspect 注解定义切面。在 XML 中的配置元素改成了注解关键字。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('package spring.tutorial.chapter4.service.impl;\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class AnnontationAdvice {\n  @Before("execution(* spring.tutorial.chapter4.service.*.withAop*(..))")\n  public void beforeAdvice() {\n    System.out.println("前置通知执行了");\n  }\n\n  @After("execution(* spring.tutorial.chapter4.service.*.withAop*(..))")\n  public void afterAdvice() {\n    System.out.println("后置通知执行了");\n  }\n\n  @AfterReturning(\n      value = "execution(* spring.tutorial.chapter4.service.*.withAop*(..))",\n      returning = "result")\n  public void afterReturnAdvice(String result) {\n    System.out.println("返回通知执行了" + "运行业务方法返回的结果为" + result);\n  }\n\n  @Around(value = "execution(* spring.tutorial.chapter4.service.*.withAop*(..))")\n  public String aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n    String result = "";\n    try {\n      System.out.println("环绕通知开始执行了");\n      long start = System.currentTimeMillis();\n      result = (String) proceedingJoinPoint.proceed();\n      long end = System.currentTimeMillis();\n      System.out.println("环绕通知执行结束了");\n      System.out.println("执行业务方法共计：" + (end - start) + "毫秒。");\n    } catch (Throwable e) {\n\n    }\n    return result;\n  }\n\n  @AfterThrowing(\n      value = "execution(* spring.tutorial.chapter4.service.*.withAop*(..))",\n      throwing = "e")\n  public void throwingAdvice(JoinPoint joinPoint, Exception e) {\n    StringBuffer stringBuffer = new StringBuffer();\n    stringBuffer.append("异常通知执行了.");\n    stringBuffer.append("方法:").append(joinPoint.getSignature().getName()).append("出现了异常.");\n    stringBuffer.append("异常信息为:").append(e.getMessage());\n    System.out.println(stringBuffer.toString());\n  }\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br"),s("span",{staticClass:"line-number"},[n._v("52")]),s("br"),s("span",{staticClass:"line-number"},[n._v("53")]),s("br"),s("span",{staticClass:"line-number"},[n._v("54")]),s("br")])]),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("在配置文件中只需配置一下自动扫描的包名，并配置`<aop:aspectj-autoproxy>`即可，比XML的配置简单一些。\n")])])]),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('\x3c!-- 配置自动扫描的包 --\x3e\n<context:component-scan base-package="spring.tutorial.chapter4.service"></context:component-scan>\n\x3c!-- 自动为切面方法中匹配的方法所在的类生成代理对象。 --\x3e\n<aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br")])]),s("p",[n._v("最后从 Spring 容器中获取 IAOPServices 对象，并分别执行 IAOPServices 中的两个方法。运行结果如下，从打印的日志可以看到拦截器拦截了 withAopMethod()方法，并未拦截 withNoAopMethod()：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("环绕通知开始执行了\n前置通知执行了\nAOP函数运行方法:withAopMethod\n环绕通知执行结束了\n执行业务方法共计：0毫秒。\n后置通知执行了\n返回通知执行了运行业务方法返回的结果为basicAop\n无AOP函数运行方法:withNoAopMethod\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br")])]),s("h2",{attrs:{id:"_4-3-小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-小结"}},[n._v("#")]),n._v(" 4.3 小结")]),n._v(" "),s("p",[n._v("本章主要从传统处理方式一步一步地引入 AOP，介绍 AOP 的主要概念，并列举了 AOP 的 3 种实现。通过本章的学习，对 AOP 思想有了更深入的认识。其实，实现 AOP 还有其他方式，这里就不一一列举了。")]),n._v(" "),s("h2",{attrs:{id:"spring-aop-与-aspectj-有什么区别和联系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop-与-aspectj-有什么区别和联系"}},[n._v("#")]),n._v(" Spring AOP 与 AspectJ 有什么区别和联系？")]),n._v(" "),s("h3",{attrs:{id:"区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[n._v("#")]),n._v(" 区别")]),n._v(" "),s("h4",{attrs:{id:"aspectj"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aspectj"}},[n._v("#")]),n._v(" AspectJ")]),n._v(" "),s("p",[n._v("AspectJ 是一个面向切面的框架，它扩展了 Java 语言。AspectJ 定义了 AOP 语法，所以它有一个"),s("strong",[n._v("专门的编译器")]),n._v("用来生成遵守 Java 字节编码规范的 Class 文件。")]),n._v(" "),s("h4",{attrs:{id:"spring-aop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop"}},[n._v("#")]),n._v(" Spring AOP")]),n._v(" "),s("p",[n._v("Spring 提供了四种类型的 AOP 支持")]),n._v(" "),s("ul",[s("li",[n._v("基于经典的 SpringAOP")]),n._v(" "),s("li",[n._v("纯 POJO 切面")]),n._v(" "),s("li",[n._v("@ASpectJ 注解驱动的切面")]),n._v(" "),s("li",[n._v("注入式 AspectJ 切面（其实与 Spring 并无多大的关系，这个就是使用 AspectJ 这个框架实现 Aop 编程）")])]),n._v(" "),s("h3",{attrs:{id:"联系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#联系"}},[n._v("#")]),n._v(" 联系")]),n._v(" "),s("p",[n._v("我们借助于 Spring AOP 的命名空间可以将纯 POJO 转换为切面，实际上这些 POJO 只是提供了满足切点的条件时所需要调用的方法，但是，这种技术需要 XML 进行配置，不能支持注解。")]),n._v(" "),s("p",[n._v("所以 Spring"),s("strong",[n._v("借鉴")]),n._v("了"),s("code",[n._v("AspectJ")]),n._v("的切面，以提供注解驱动的 AOP，本质上它依然是 Spring 基于代理的 AOP，只是编程模型与 AspectJ 完全一致，这种风格的好处就是不需要使用 XML 进行配置。")]),n._v(" "),s("p",[n._v("使用@Aspect 方式，你就可以在类上直接一个"),s("code",[n._v("@Aspect")]),n._v("就搞定，不用费事在 xml 里配了。但是这需要额外的 jar 包（"),s("code",[n._v("aspectjweaver.jar")]),n._v("）。因为 spring 直接使用"),s("code",[n._v("AspectJ")]),n._v("的"),s("strong",[n._v("注解功能，注意只是使用了它 的注解功能而已，并不是核心功能")]),n._v(" 。")]),n._v(" "),s("blockquote",[s("p",[n._v("SpringAOP 的底层技术依然是 Jdk 动态代理和 Cglib。")])])])}),[],!1,null,null,null);s.default=a.exports}}]);