(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{1209:function(s,a,e){s.exports=e.p+"assets/img/image-20231206232004484.853b6ceb.png"},1210:function(s,a,e){s.exports=e.p+"assets/img/image-20231206232152303.0a5e7a5b.png"},1211:function(s,a,e){s.exports=e.p+"assets/img/image-20231206232811635.ab136314.png"},1212:function(s,a,e){s.exports=e.p+"assets/img/image-20231206233014681.714f592a.png"},1213:function(s,a,e){s.exports=e.p+"assets/img/image-20231206233148466.d5bcd251.png"},1538:function(s,a,e){"use strict";e.r(a);var n=e(4),t=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"_6-rdd-序列化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-rdd-序列化"}},[s._v("#")]),s._v(" 6. RDD 序列化")]),s._v(" "),a("h2",{attrs:{id:"_6-1-闭包检查"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-闭包检查"}},[s._v("#")]),s._v(" 6.1 闭包检查")]),s._v(" "),a("p",[s._v("从计算的角度,"),a("mark",[a("strong",[s._v("算子以外的代码都是在 Driver 端执行")]),s._v(", "),a("strong",[s._v("算子里面的代码都是在 Executor 端执行")])]),s._v("。那么在 scala 的函数式编程中，就会导致算子内经常会用到算子外的数据，这样就形成了闭包的效果，如果使用的算子外的数据无法序列化，就意味着无法传值给 Executor 端执行，就会发生错误，所以需要在执行任务计算前，检测闭包内的对象是否可以进行序列化，这个操作我们称之为"),a("strong",[s._v("闭包检测")]),s._v("。Scala2.12 版本后闭包编译方式发生了改")]),s._v(" "),a("h2",{attrs:{id:"_6-2-序列化方法和属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-序列化方法和属性"}},[s._v("#")]),s._v(" 6.2 序列化方法和属性")]),s._v(" "),a("p",[a("mark",[s._v("从计算的角度, 算子以外的代码都是在 Driver 端执行, 算子里面的代码都是在 Executor 端执行")]),s._v("，看如下代码：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('    object Spark01_RDD_Serial {\n\n        def main(args: Array[String]): Unit = {\n            val sparConf = new SparkConf().setMaster("local").setAppName("WordCount")\n            val sc = new SparkContext(sparConf)\n\n            val rdd: RDD[String] = sc.makeRDD(Array("hello world", "hello spark", "hive", "haddoop"))\n\n            val search = new Search("h")\n\n            //search.getMatch1(rdd).collect().foreach(println)\n            search.getMatch2(rdd).collect().foreach(println)\n\n            sc.stop()\n        }\n        // 查询对象\n        // 类的构造参数其实是类的属性, 构造参数需要进行闭包检测，其实就等同于类进行闭包检测\n        class Search(query:String){\n\n            def isMatch(s: String): Boolean = {\n                s.contains(this.query)\n            }\n\n            // 函数序列化案例\n            def getMatch1 (rdd: RDD[String]): RDD[String] = {\n                rdd.filter(isMatch)\n            }\n\n            // 属性序列化案例\n            def getMatch2(rdd: RDD[String]): RDD[String] = {\n                val s = query\n                rdd.filter(x => x.contains(s))\n            }\n        }\n    }\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br")])]),a("h2",{attrs:{id:"_6-3-kryo-序列化框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-kryo-序列化框架"}},[s._v("#")]),s._v(" 6.3 Kryo 序列化框架")]),s._v(" "),a("p",[s._v("参考地址: https://github.com/EsotericSoftware/kryo")]),s._v(" "),a("p",[s._v("Java 的序列化能够序列化任何的类。但是比较重（字节多），序列化后，对象的提交也比较大。Spark 出于性能的考虑，Spark2.0 开始支持另外一种 Kryo 序列化机制。Kryo 速度 是 Serializable 的 10 倍。当 RDD 在 Shuffle 数据的时候，简单数据类型、数组和字符串类型已经在 Spark 内部使用 Kryo 来序列化。 注意：即使使用 Kryo 序列化，也要继承 Serializable 接口。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('    object serializable_Kryo {\n      def main(args: Array[String]): Unit = {\n        val conf: SparkConf = new SparkConf()\n          .setAppName("SerDemo")\n          .setMaster("local[*]")\n          // 替换默认的序列化机制\n          .set("spark.serializer",\n            "org.apache.spark.serializer.KryoSerializer")\n          // 注册需要使用 kryo 序列化的自定义类\n          .registerKryoClasses(Array(classOf[Searcher]))\n\n        val sc = new SparkContext(conf)\n        val rdd: RDD[String] = sc.makeRDD(Array("hello world", "hello spark",\n          "spark", "hahah"), 2)\n        val searcher = new Searcher("hello")\n        val result: RDD[String] = searcher.getMatchedRDD1(rdd)\n        result.collect.foreach(println)\n      }\n    }\n\n    case class Searcher(val query: String) {\n      def getMatchedRDD1(rdd: RDD[String]) = {\n        rdd.filter(isMatch)\n      }\n\n      def isMatch(s: String) = {\n        s.contains(query)\n      }\n\n      def getMatchedRDD2(rdd: RDD[String]) = {\n        val q = query\n        rdd.filter(_.contains(q))\n      }\n    }\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br")])]),a("h1",{attrs:{id:"_7-rdd-依赖关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-rdd-依赖关系"}},[s._v("#")]),s._v(" 7 RDD 依赖关系")]),s._v(" "),a("h2",{attrs:{id:"_7-1-rdd-血缘关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-rdd-血缘关系"}},[s._v("#")]),s._v(" 7.1 RDD 血缘关系")]),s._v(" "),a("p",[s._v("RDD 只支持粗粒度转换，即在大量记录上执行的单个操作。将创建 RDD 的一系列 Lineage （血统）记录下来，以便恢复丢失的分区。RDD 的 Lineage 会记录 RDD 的元数据信息和转换行为，当该 RDD 的部分分区数据丢失时，它可以根据这些信息来重新运算和恢复丢失的数据分区。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('val fileRDD: RDD[String] = sc.textFile("input/1.txt")\nprintln(fileRDD.toDebugString)\nprintln("----------------------")\nval wordRDD: RDD[String] = fileRDD.flatMap(_.split(" "))\nprintln(wordRDD.toDebugString)\nprintln("----------------------")\nval mapRDD: RDD[(String, Int)] = wordRDD.map((_,1))\nprintln(mapRDD.toDebugString)\nprintln("----------------------")\nval resultRDD: RDD[(String, Int)] = mapRDD.reduceByKey(_+_)\nprintln(resultRDD.toDebugString)\nresultRDD.collect()\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[a("img",{attrs:{src:e(1209),alt:"image-20231206232004484"}})]),s._v(" "),a("h2",{attrs:{id:"_7-2-rdd-依赖关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-rdd-依赖关系"}},[s._v("#")]),s._v(" 7.2 RDD 依赖关系")]),s._v(" "),a("p",[s._v("这里所谓的依赖关系，其实就是两个相邻 RDD 之间的关系")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('val sc: SparkContext = new SparkContext(conf)\nval fileRDD: RDD[String] = sc.textFile("input/1.txt")\nprintln(fileRDD.dependencies)\nprintln("----------------------")\nval wordRDD: RDD[String] = fileRDD.flatMap(_.split(" "))\nprintln(wordRDD.dependencies)\nprintln("----------------------")\nval mapRDD: RDD[(String, Int)] = wordRDD.map((_,1))\nprintln(mapRDD.dependencies)\nprintln("----------------------")\nval resultRDD: RDD[(String, Int)] = mapRDD.reduceByKey(_+_)\nprintln(resultRDD.dependencies)\nresultRDD.collect()\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[a("img",{attrs:{src:e(1210),alt:"image-20231206232152303"}})]),s._v(" "),a("h2",{attrs:{id:"_7-3-rdd-窄依赖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-rdd-窄依赖"}},[s._v("#")]),s._v(" 7.3 RDD 窄依赖")]),s._v(" "),a("p",[s._v("窄依赖表示每一个父(上游)RDD 的 Partition 最多被子（下游）RDD 的一个 Partition 使用， 窄依赖我们形象的比喻为独生子女。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class OneToOneDependency[T](rdd: RDD[T]) extends NarrowDependency[T](rdd)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h2",{attrs:{id:"_7-4-rdd-宽依赖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-rdd-宽依赖"}},[s._v("#")]),s._v(" 7.4 RDD 宽依赖")]),s._v(" "),a("p",[s._v("宽依赖表示同一个父（上游）RDD 的 Partition 被多个子（下游）RDD 的 Partition 依赖，会引起 Shuffle，总结：宽依赖我们形象的比喻为多生。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class ShuffleDependency[K: ClassTag, V: ClassTag, C: ClassTag](\n @transient private val _rdd: RDD[_ <: Product2[K, V]],\n val partitioner: Partitioner,\n val serializer: Serializer = SparkEnv.get.serializer,\n val keyOrdering: Option[Ordering[K]] = None,\n val aggregator: Option[Aggregator[K, V, C]] = None,\n val mapSideCombine: Boolean = false)\n extends Dependency[Product2[K, V]]\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h2",{attrs:{id:"_7-5-rdd-阶段划分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-rdd-阶段划分"}},[s._v("#")]),s._v(" 7.5 RDD 阶段划分")]),s._v(" "),a("p",[s._v("DAG（Directed Acyclic Graph）有向无环图是由点和线组成的拓扑图形，该图形具有方向， 不会闭环。例如，DAG 记录了 RDD 的转换过程和任务的阶段。")]),s._v(" "),a("p",[a("img",{attrs:{src:e(1211),alt:"image-20231206232811635"}})]),s._v(" "),a("h2",{attrs:{id:"_7-6-rdd-阶段划分源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-rdd-阶段划分源码"}},[s._v("#")]),s._v(" 7.6 RDD 阶段划分源码")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('try {\n // New stage creation may throw an exception if, for example, jobs are run on\na\n // HadoopRDD whose underlying HDFS files have been deleted.\n finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)\n} catch {\n case e: Exception =>\n logWarning("Creating new stage failed due to exception - job: " + jobId, e)\n listener.jobFailed(e)\n return\n}\n……\nprivate def createResultStage(\n rdd: RDD[_],\n func: (TaskContext, Iterator[_]) => _,\n partitions: Array[Int],\n jobId: Int,\n callSite: CallSite): ResultStage = {\nval parents = getOrCreateParentStages(rdd, jobId)\nval id = nextStageId.getAndIncrement()\nval stage = new ResultStage(id, rdd, func, partitions, parents, jobId, callSite)\nstageIdToStage(id) = stage\nupdateJobIdStageIdMaps(jobId, stage)\nstage\n}\n……\nprivate def getOrCreateParentStages(rdd: RDD[_], firstJobId: Int): List[Stage]\n= {\ngetShuffleDependencies(rdd).map { shuffleDep =>\n getOrCreateShuffleMapStage(shuffleDep, firstJobId)\n}.toList\n}\n……\nprivate[scheduler] def getShuffleDependencies(\n rdd: RDD[_]): HashSet[ShuffleDependency[_, _, _]] = {\nval parents = new HashSet[ShuffleDependency[_, _, _]]\nval visited = new HashSet[RDD[_]]\nval waitingForVisit = new Stack[RDD[_]]\nwaitingForVisit.push(rdd)\nwhile (waitingForVisit.nonEmpty) {\n val toVisit = waitingForVisit.pop()\n if (!visited(toVisit)) {\n visited += toVisit\n toVisit.dependencies.foreach {\n case shuffleDep: ShuffleDependency[_, _, _] =>\n parents += shuffleDep\n case dependency =>\n waitingForVisit.push(dependency.rdd)\n }\n }\n}\nparents\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br"),a("span",{staticClass:"line-number"},[s._v("47")]),a("br"),a("span",{staticClass:"line-number"},[s._v("48")]),a("br"),a("span",{staticClass:"line-number"},[s._v("49")]),a("br"),a("span",{staticClass:"line-number"},[s._v("50")]),a("br"),a("span",{staticClass:"line-number"},[s._v("51")]),a("br"),a("span",{staticClass:"line-number"},[s._v("52")]),a("br"),a("span",{staticClass:"line-number"},[s._v("53")]),a("br")])]),a("h2",{attrs:{id:"_7-7-rdd-任务划分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-7-rdd-任务划分"}},[s._v("#")]),s._v(" 7.7 RDD 任务划分")]),s._v(" "),a("p",[s._v("RDD 任务切分中间分为：Application、Job、Stage 和 Task")]),s._v(" "),a("ul",[a("li",[s._v("Application：初始化一个 SparkContext 即生成一个 Application；")]),s._v(" "),a("li",[s._v("Job：一个 Action 算子就会生成一个 Job；")]),s._v(" "),a("li",[s._v("Stage：Stage 等于宽依赖(ShuffleDependency)的个数加 1；")]),s._v(" "),a("li",[s._v("Task：一个 Stage 阶段中，最后一个 RDD 的分区个数就是 Task 的个数。")])]),s._v(" "),a("blockquote",[a("p",[s._v("注意：Application->Job->Stage->Task 每一层都是 1 对 n 的关系")])]),s._v(" "),a("p",[a("img",{attrs:{src:e(1212),alt:"image-20231206233014681"}})]),s._v(" "),a("h1",{attrs:{id:"_8-rdd-持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-rdd-持久化"}},[s._v("#")]),s._v(" 8. RDD 持久化")]),s._v(" "),a("h2",{attrs:{id:"_8-1-rdd-cache-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-rdd-cache-缓存"}},[s._v("#")]),s._v(" 8.1 RDD Cache 缓存")]),s._v(" "),a("p",[s._v("RDD 通过 Cache 或者 Persist 方法将前面的计算结果缓存，默认情况下会把数据以缓存在 JVM 的堆内存中。但是并不是这两个方法被调用时立即缓存，而是触发后面的 action 算子时，该 RDD 将会被缓存在计算节点的内存中，并供后面重用。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// cache 操作会增加血缘关系，不改变原有的血缘关系\nprintln(wordToOneRdd.toDebugString)\n// 数据缓存。\nwordToOneRdd.cache()\n// 可以更改存储级别\n//mapRdd.persist(StorageLevel.MEMORY_AND_DISK_2)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("存储级别")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("object StorageLevel {\n val NONE = new StorageLevel(false, false, false, false)\n val DISK_ONLY = new StorageLevel(true, false, false, false)\n val DISK_ONLY_2 = new StorageLevel(true, false, false, false, 2)\n val MEMORY_ONLY = new StorageLevel(false, true, false, true)\n val MEMORY_ONLY_2 = new StorageLevel(false, true, false, true, 2)\n val MEMORY_ONLY_SER = new StorageLevel(false, true, false, false)\n val MEMORY_ONLY_SER_2 = new StorageLevel(false, true, false, false, 2)\n val MEMORY_AND_DISK = new StorageLevel(true, true, false, true)\n val MEMORY_AND_DISK_2 = new StorageLevel(true, true, false, true, 2)\n val MEMORY_AND_DISK_SER = new StorageLevel(true, true, false, false)\n val MEMORY_AND_DISK_SER_2 = new StorageLevel(true, true, false, false, 2)\n val OFF_HEAP = new StorageLevel(true, true, true, false, 1)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[a("img",{attrs:{src:e(1213),alt:"image-20231206233148466"}})]),s._v(" "),a("p",[s._v("缓存有可能丢失，或者存储于内存的数据由于内存不足而被删除，RDD 的缓存容错机 制保证了即使缓存丢失也能保证计算的正确执行。通过基于 RDD 的一系列转换，丢失的数据会被重算，由于 RDD 的各个 Partition 是相对独立的，因此只需要计算丢失的部分即可， 并不需要重算全部 Partition。")]),s._v(" "),a("p",[s._v("Spark 会自动对一些 Shuffle 操作的中间数据做持久化操作(比如：reduceByKey)。这样 做的目的是为了当一个节点 Shuffle 失败了避免重新计算整个输入。但是，在实际使用的时 候，如果想重用数据，仍然建议调用 persist 或 cache。")]),s._v(" "),a("h2",{attrs:{id:"_8-2-rdd-checkpoint-检查点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-rdd-checkpoint-检查点"}},[s._v("#")]),s._v(" 8.2 RDD CheckPoint 检查点")]),s._v(" "),a("p",[s._v("所谓的检查点其实就是通过"),a("strong",[s._v("将 RDD 中间结果写入磁盘")])]),s._v(" "),a("p",[s._v("由于血缘依赖过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果检查点之后有节点出现问题，可以从检查点开始重做血缘，减少了开销。 对 RDD 进行 checkpoint 操作并不会马上被执行，必须执行 Action 操作才能触发。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// 设置检查点路径\nsc.setCheckpointDir("./checkpoint1")\n// 创建一个 RDD，读取指定位置文件:hello atguigu atguigu\nval lineRdd: RDD[String] = sc.textFile("input/1.txt")\n// 业务逻辑\nval wordRdd: RDD[String] = lineRdd.flatMap(line => line.split(" "))\nval wordToOneRdd: RDD[(String, Long)] = wordRdd.map {\n word => {\n (word, System.currentTimeMillis())\n }\n}\n// 增加缓存,避免再重新跑一个 job 做 checkpoint\nwordToOneRdd.cache()\n// 数据检查点：针对 wordToOneRdd 做检查点计算\nwordToOneRdd.checkpoint()\n// 触发执行逻辑\nwordToOneRdd.collect().foreach(println\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br")])]),a("h2",{attrs:{id:"_8-3-缓存和检查点区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-缓存和检查点区别"}},[s._v("#")]),s._v(" 8.3 缓存和检查点区别")]),s._v(" "),a("p",[s._v("1）Cache 缓存只是将数据保存起来，不切断血缘依赖。Checkpoint 检查点切断血缘依赖。")]),s._v(" "),a("p",[s._v("2）Cache 缓存的数据通常存储在磁盘、内存等地方，可靠性低。Checkpoint 的数据通常存储在 HDFS 等容错、高可用的文件系统，可靠性高。")]),s._v(" "),a("p",[s._v("3）建议对 checkpoint()的 RDD 使用 Cache 缓存，这样 checkpoint 的 job 只需从 Cache 缓存中读取数据即可，否则需要再从头计算一次 RDD。")]),s._v(" "),a("h1",{attrs:{id:"_9-rdd-分区器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-rdd-分区器"}},[s._v("#")]),s._v(" 9 RDD 分区器")]),s._v(" "),a("p",[s._v("Spark 目前支持 Hash 分区和 Range 分区，和用户自定义分区。Hash 分区为当前的默认分区。分区器直接决定了 RDD 中分区的个数、RDD 中每条数据经过 Shuffle 后进入哪个分区，进而决定了 Reduce 的个数。")]),s._v(" "),a("p",[s._v("➢ 只有 Key-Value 类型的 RDD 才有分区器，非 Key-Value 类型的 RDD 分区的值是 None")]),s._v(" "),a("p",[s._v("➢ 每个 RDD 的分区 ID 范围：0 ~ (numPartitions - 1)，决定这个值是属于那个分区的。")]),s._v(" "),a("h2",{attrs:{id:"_9-1-hash-分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-hash-分区"}},[s._v("#")]),s._v(" 9.1 Hash 分区：")]),s._v(" "),a("p",[s._v("对于给定的 key，计算其 hashCode,并除以分区个数取余")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('class HashPartitioner(partitions: Int) extends Partitioner {\n require(partitions >= 0, s"Number of partitions ($partitions) cannot be\nnegative.")\n def numPartitions: Int = partitions\n def getPartition(key: Any): Int = key match {\n case null => 0\n case _ => Utils.nonNegativeMod(key.hashCode, numPartitions)\n }\n override def equals(other: Any): Boolean = other match {\n case h: HashPartitioner =>\n h.numPartitions == numPartitions\n case _ =>\n false\n }\n override def hashCode: Int = numPartitions\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("h2",{attrs:{id:"_9-2-range-分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-range-分区"}},[s._v("#")]),s._v(" 9.2 Range 分区")]),s._v(" "),a("p",[s._v("将一定范围内的数据映射到一个分区中，尽量保证每个分区数据均匀，而 且分区间有序")]),s._v(" "),a("h1",{attrs:{id:"_10-rdd-文件读取与保存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-rdd-文件读取与保存"}},[s._v("#")]),s._v(" 10 RDD 文件读取与保存")]),s._v(" "),a("p",[s._v("Spark 的数据读取及数据保存可以从两个维度来作区分：文件格式以及文件系统。 文件格式分为：text 文件、csv 文件、sequence 文件以及 Object 文件； 文件系统分为：本地文件系统、HDFS、HBASE 以及数据库。")]),s._v(" "),a("h2",{attrs:{id:"_10-1-text-文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-text-文件"}},[s._v("#")]),s._v(" 10.1 text 文件")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// 读取输入文件\nval inputRDD: RDD[String] = sc.textFile("input/1.txt")\n// 保存数据\ninputRDD.saveAsTextFile("output")\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h2",{attrs:{id:"_10-2-sequence-文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-sequence-文件"}},[s._v("#")]),s._v(" 10.2 sequence 文件")]),s._v(" "),a("p",[s._v("SequenceFile 文件是 Hadoop 用来存储二进制形式的 key-value 对而设计的一种平面文件(Flat File)。在 SparkContext 中，可以调用 "),a("code",[s._v("sequenceFile[keyClass, valueClass](path)")]),s._v("。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// 保存数据为 SequenceFile\ndataRDD.saveAsSequenceFile("output")\n// 读取 SequenceFile 文件\nsc.sequenceFile[Int,Int]("output").collect().foreach(println)\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h2",{attrs:{id:"_10-3-object-对象文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-3-object-对象文件"}},[s._v("#")]),s._v(" 10.3 object 对象文件")]),s._v(" "),a("p",[s._v("对象文件是将对象序列化后保存的文件，采用 Java 的序列化机制。可以通过 "),a("code",[s._v("objectFile[T: ClassTag](path)")]),s._v("函数接收一个路径，读取对象文件，返回对应的 RDD，也可以通过调用 saveAsObjectFile()实现对对象文件的输出。因为是序列化所以要指定类型。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// 保存数据\ndataRDD.saveAsObjectFile("output")\n// 读取数据\nsc.objectFile[Int]("output").collect().foreach(println\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])])])}),[],!1,null,null,null);a.default=t.exports}}]);